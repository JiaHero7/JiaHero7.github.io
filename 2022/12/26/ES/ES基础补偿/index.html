<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>ES基础补偿 | 贾英雄-blog</title><meta name="keywords" content="ES"><meta name="author" content="JaHero"><meta name="copyright" content="JaHero"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="ES基础补偿著作权归https:&#x2F;&#x2F;pdai.tech所有。 链接：https:&#x2F;&#x2F;www.pdai.tech&#x2F;md&#x2F;db&#x2F;nosql-es&#x2F;elasticsearch-x-index-template.html 查询与聚合布尔查询must, should, must_not 和 filter 都是bool查询的子句。那么filter和上述query子句有啥区别呢？ query 上下文的条件是用来">
<meta property="og:type" content="article">
<meta property="og:title" content="ES基础补偿">
<meta property="og:url" content="http://example.com/2022/12/26/ES/ES%E5%9F%BA%E7%A1%80%E8%A1%A5%E5%81%BF/index.html">
<meta property="og:site_name" content="贾英雄-blog">
<meta property="og:description" content="ES基础补偿著作权归https:&#x2F;&#x2F;pdai.tech所有。 链接：https:&#x2F;&#x2F;www.pdai.tech&#x2F;md&#x2F;db&#x2F;nosql-es&#x2F;elasticsearch-x-index-template.html 查询与聚合布尔查询must, should, must_not 和 filter 都是bool查询的子句。那么filter和上述query子句有啥区别呢？ query 上下文的条件是用来">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/post.jpg">
<meta property="article:published_time" content="2022-12-26T04:40:09.000Z">
<meta property="article:modified_time" content="2022-12-26T05:07:37.091Z">
<meta property="article:author" content="JaHero">
<meta property="article:tag" content="ES">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/post.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/12/26/ES/ES%E5%9F%BA%E7%A1%80%E8%A1%A5%E5%81%BF/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css" media="print" onload="this.media='all'"><script src="https://fastly.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"K46KXS6BKG","apiKey":"94dab3de87ce4cc2067ec6ef569e9df7","indexName":"JiaHero","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: JaHero","link":"链接: ","source":"来源: 贾英雄-blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://fastly.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://fastly.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://fastly.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://fastly.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://fastly.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ES基础补偿',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2022-12-26 13:07:37'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    document.addEventListener('pjax:complete', detectApple)})(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/ava.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">495</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">294</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">118</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/photos/"><i class="fa-fw image"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/post.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">贾英雄-blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/photos/"><i class="fa-fw image"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">ES基础补偿</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-26T04:40:09.000Z" title="发表于 2022-12-26 12:40:09">2022-12-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-26T05:07:37.091Z" title="更新于 2022-12-26 13:07:37">2022-12-26</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>39分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="ES基础补偿"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="ES基础补偿"><a href="#ES基础补偿" class="headerlink" title="ES基础补偿"></a>ES基础补偿</h1><p>著作权归<a target="_blank" rel="noopener" href="https://pdai.tech所有./">https://pdai.tech所有。</a> <a href="">链接：</a><a target="_blank" rel="noopener" href="https://www.pdai.tech/md/db/nosql-es/elasticsearch-x-index-template.html">https://www.pdai.tech/md/db/nosql-es/elasticsearch-x-index-template.html</a></p>
<h2 id="查询与聚合"><a href="#查询与聚合" class="headerlink" title="查询与聚合"></a>查询与聚合</h2><h3 id="布尔查询"><a href="#布尔查询" class="headerlink" title="布尔查询"></a>布尔查询</h3><p><code>must</code>, <code>should</code>, <code>must_not</code> 和 <code>filter</code> 都是<code>bool</code>查询的子句。那么<code>filter</code>和上述<code>query</code>子句有啥区别呢？</p>
<p><strong>query 上下文的条件是用来给文档打分的，匹配越好 _score 越高；filter 的条件只产生两种结果：符合与不符合，后者被过滤掉</strong>。</p>
<p>bool查询中filter是不计算分数的，其他三个是会计算分数，匹配度越高分数越高，当只有filter是，分数为0。</p>
<p>没有布尔查询，hits文档返回为0</p>
<h3 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h3><p><strong>在sql中为groupby</strong></p>
<p>aggs中的terms 聚合，它是按照某个字段中的值来分类，统计值得数量，值有几种就有几个桶。例如gender（男，女），就会分为两个桶。</p>
<h3 id="嵌套聚合"><a href="#嵌套聚合" class="headerlink" title="嵌套聚合"></a>嵌套聚合</h3><p>ES还可以处理个聚合条件的嵌套。</p>
<p>比如承接上个例子， 计算男女的桶中的某个字段进行平均结余。涉及到的就是在对gender分组的基础上，嵌套计算avg(balance):</p>
<h3 id="对聚合结果排序"><a href="#对聚合结果排序" class="headerlink" title="对聚合结果排序"></a>对聚合结果排序</h3><p><img src="C:\Users\JT\AppData\Roaming\Typora\typora-user-images\image-20221013155853403.png" alt="image-20221013155853403"></p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p><strong>禁止自动创建索引</strong></p>
<p>想要确保这个索引有数量适中的主分片，并且在我们索引任何数据之前，词条分析器和映射已经被建立好</p>
<p>可以通过在 config&#x2F;elasticsearch.yml 的每个节点下添加下面的配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">action.auto_create_index: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>number_of_shards 是指索引要做多少个分片，只能在创建索引时指定，后期无法修改。<br>number_of_replicas 是指每个分片有多少个副本，后期可以动态修改</p>
<p>primary shard：主分片，每个文档都存储在一个分片中，当你存储一个文档的时候，系统会首先存储在主分片中，然后会复制到不同的副本中。默认情况下，一个索引有5个主分片。你可以在事先制定分片的数量，当分片一旦建立，分片的数量则不能修改。</p>
<p>replica shard：副本分片，每一个分片有零个或多个副本。副本主要是主分片的复制，可以 增加高可用性，提高性能。<br>默认情况下，一个主分配有一个副本，但副本的数量可以在后面动态的配置增加。<br>副本必须部署在不同的节点上，不能部署在和主分片相同的节点上。</p>
<h3 id="索引模板"><a href="#索引模板" class="headerlink" title="索引模板"></a>索引模板</h3><p>索引模板用于快速构建和管理索引</p>
<p>索引模板是一种告诉Elasticsearch在创建索引时如何配置索引的方法。</p>
<p>使用方式</p>
<p>先设置模板，然后将模板作为后续创建索引的基础</p>
<h3 id="模板类型"><a href="#模板类型" class="headerlink" title="模板类型"></a>模板类型</h3><p>模板有两种类型：<strong>索引模板</strong>和<strong>组件模板</strong>。</p>
<ol>
<li><strong>组件模板</strong>是可重用的构建块，用于配置映射，设置和别名；它们不会直接应用于一组索引。</li>
<li><strong>索引模板</strong>可以包含组件模板的集合，也可以直接指定设置，映射和别名。</li>
</ol>
<h3 id="索引模板中的优先级"><a href="#索引模板中的优先级" class="headerlink" title="索引模板中的优先级"></a>索引模板中的优先级</h3><ol>
<li>可组合模板优先于旧模板。如果没有可组合模板匹配给定索引，则旧版模板可能仍匹配并被应用。</li>
<li>如果使用显式设置创建索引并且该索引也与索引模板匹配，则创建索引请求中的设置将优先于索引模板及其组件模板中指定的设置。</li>
<li>如果新数据流或索引与多个索引模板匹配，则使用优先级最高的索引模板。</li>
</ol>
<h3 id="内置索引模板"><a href="#内置索引模板" class="headerlink" title="内置索引模板"></a>内置索引模板</h3><p>Elasticsearch具有内置索引模板，每个索引模板的优先级为100，适用于以下索引模式：</p>
<ol>
<li><code>logs-*-*</code></li>
<li><code>metrics-*-*</code></li>
<li><code>synthetics-*-*</code></li>
</ol>
<p>所以在涉及内建索引模板时，要避免索引模式冲突。更多可以参考<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index-templates.html">这里  (opens new window)</a></p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><h2 id="DSL查询之全文搜索详解"><a href="#DSL查询之全文搜索详解" class="headerlink" title="DSL查询之全文搜索详解"></a>DSL查询之全文搜索详解</h2><h3 id="1-match搜索"><a href="#1-match搜索" class="headerlink" title="1.match搜索"></a>1.match搜索</h3><p>执行顺序：</p>
<p>检查字段类型-&gt;传入分词器中对字符串分词，然后使用多个底层term查询-&gt;在倒排索引中获取文档编号-&gt;对字符串进行词频（当前文档中的频率）、反向词频（所有文档中字符串频率）以及（字符串的长短）相计算得出分数，然后汇总文档的分数相加 。</p>
<p>操作数（<strong>match多个词的逻辑</strong>）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;operator&quot;</span>: <span class="string">&quot;or&quot;</span></span><br></pre></td></tr></table></figure>

<p>or 相当于should，and相当于must</p>
<h4 id="2-控制match的匹配精度"><a href="#2-控制match的匹配精度" class="headerlink" title="2.控制match的匹配精度"></a>2.控制match的匹配精度</h4><p>如果用户给定 3 个查询词，想查找至少包含其中 2 个的文档，该如何处理？将 operator 操作符参数设置成 and 或者 or 都是不合适的。</p>
<p>match 查询支持 minimum_should_match 最小匹配参数，这让我们可以指定必须匹配的词项数用来表示一个文档是否相关。我们可以将其设置为某个具体数字，更常用的做法是将其设置为一个百分数，因为我们无法控制用户搜索时输入的单词数量：</p>
<p><strong>75%大于2&#x2F;3所以满足</strong></p>
<p><img src="C:\Users\JT\AppData\Roaming\Typora\typora-user-images\image-20221017175417036.png" alt="image-20221017175417036"></p>
<p><img src="C:\Users\JT\AppData\Roaming\Typora\typora-user-images\image-20221017175901977.png" alt="image-20221017175901977"></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gwd1154978352/article/details/84141627">https://blog.csdn.net/gwd1154978352/article/details/84141627</a></p>
<h4 id="3-近似匹配"><a href="#3-近似匹配" class="headerlink" title="3.近似匹配"></a>3.近似匹配</h4><p>如果说，要实现两个需求：</p>
<p>1、java spark，就靠在一起，中间不能插入任何其他字符，就要搜索出来这种doc<br>2、java spark，但是要求，java和spark两个单词靠的越近，doc的分数越高，排名越靠前</p>
<p>要实现上述两个需求，用match做全文检索，是搞不定的，必须得用proximity match，近似匹配</p>
<p>phrase match，proximity match：短语匹配，近似匹配</p>
<p>这一讲，要学习的是phrase match，就是仅仅搜索出java和spark靠在一起的那些doc，比如有个doc，是java d spark，不行。必须是比如java spark are very good friends，是可以搜索出来的。</p>
<p>phrase match，就是要去将多个term作为一个短语，一起去搜索，只有包含这个短语的doc才会作为结果返回。不像是match，java spark，java的doc也会返回，spark的doc也会返回。</p>
<p><strong>match_phrase只会返回包含java spark这个短语</strong></p>
<h3 id="扩展-分词位置"><a href="#扩展-分词位置" class="headerlink" title="扩展-分词位置"></a>扩展-分词位置</h3><p><strong>词条的位置在文档中记录位置</strong>，对应偏移量</p>
<p><img src="C:\Users\JT\AppData\Roaming\Typora\typora-user-images\image-20221017185042703.png" alt="image-20221017185042703"></p>
<h4 id="4、match-phrase的原理"><a href="#4、match-phrase的原理" class="headerlink" title="4、match_phrase的原理"></a>4、match_phrase的原理</h4><p>索引中的position，match_phrase</p>
<p>hello world, java spark     doc1<br>hi, spark java         doc2</p>
<p>hello      doc1(0)<br>wolrd     doc1(1)<br>java         doc1(2) doc2(2)<br>spark     doc1(3) doc2(1)</p>
<p>java spark –&gt; match phrase</p>
<p>先进行match query查询，得到词条在文档的位置，然后在文档列表中找出包含所有词条的文档，然后进行比较词条在文档中的索引位置（词条的位置是有先后顺序的）。</p>
<!--java spark --> java和spark-->

<!--java --> doc1(2) doc2(2)-->
<!--spark --> doc1(3) doc2(1)-->

<!--要找到每个term都在的一个共有的那些doc，就是要求一个doc，必须包含每个term，才能拿出来继续计算-->

<!--doc1 --> java和spark --> spark position恰巧比java大1 --> java的position是2，spark的position是3，恰好满足条件-->

<!--doc1符合条件-->

<!--doc2 --> java和spark --> java position是2，spark position是1，spark position比java position小1，而不是大1 --> 光是position就不满足，那么doc2不匹配-->

<!--必须理解这块原理！！！！-->

<!--因为后面的proximity match就是原理跟这个一模一样！！！-->

<h5 id="1、引入slop"><a href="#1、引入slop" class="headerlink" title="1、引入slop"></a>1、引入slop</h5><p>短语匹配的是只匹配短语，不会单个分词匹配，加上slop（移动）实现近似匹配</p>
<p>实际举例，一个query string经过几次移动之后可以匹配到一个document，然后设置slop（最大移动步数）</p>
<p><strong>slop搜索下，关键词离的越近，relevance（关联） score就会越高</strong>，排在最前</p>
<h5 id="2、引入召回率"><a href="#2、引入召回率" class="headerlink" title="2、引入召回率"></a>2、引入召回率</h5><p>比如你搜索一个java spark，总共有100个doc，能返回多少个doc作为结果，就是召回率，recall</p>
<h5 id="3、引入精准度"><a href="#3、引入精准度" class="headerlink" title="3、引入精准度"></a>3、引入精准度</h5><p>使用match-&gt;文档进行分词匹配</p>
<p>match phrase-&gt;短语匹配</p>
<p>match proximity-&gt;近似匹配</p>
<p>在近似匹配的基础上提高召回率，降低精准度 </p>
<p>首先是满足召回率，将文档进行分词返回（包含了短语、近似匹配），然后兼顾精准度，分数高的排在最前面（进行关联评分）</p>
<p>GET &#x2F;forum&#x2F;article&#x2F;_search<br>{<br>  “query”: {<br>    “bool”: {<br>      “must”: {<br>        “match”: {<br>          “title”: {<br>            “query”:  “java spark” –&gt; java或spark或java spark，java和spark靠前，但是没法区分java和spark的距离，也许java和spark靠的很近，但是没法排在最前面<br>          }<br>        }<br>      },<br>      “should”: {<br>        “match_phrase”: { –&gt; 在slop以内，<strong>如果java spark能匹配上一个doc，那么就会对doc贡献自己的relevance score，如果java和spark靠的越近，那么就分数越高</strong><br>          “title”: {<br>            “query”: “java spark”,<br>            “slop”:  50<br>          }<br>        }<br>      }<br>    }<br>  }<br>}</p>
<h5 id="match和phrase-match-proximity-match-区别"><a href="#match和phrase-match-proximity-match-区别" class="headerlink" title="match和phrase match(proximity match)区别"></a>match和phrase match(proximity match)区别</h5><p><strong>执行原理差异</strong></p>
<p>match ：将字符串进行分词后，将各个词扫描倒排索引，返回结果 </p>
<p>phrase match </p>
<p>1、扫描处包含所有分词的文档列表，对每个文档中term进行位置进行判断（在字符串中的前后顺序）</p>
<p>2、引入slop，进行最大移动次数匹配term的位置进行返回。</p>
<p><strong>执行效率差异</strong></p>
<p>match 一般就在几毫秒，或者几十毫秒</p>
<p>match执行效率，比短语匹配高10倍，比近似匹配要高20倍。</p>
<p>为优化proximity match的性能，可以从减少返回的文档数量下手。</p>
<p>一般情况下，需要对查询进行分页，分页的数量不会很大，所以只需要设置到返回的分页数量进行评分就好。</p>
<p>而前面使用的match + proximity match同时实现召回率和精准度，但是should不能设置返回的文档数量，需要使用到rescore，重计分<br><strong>例如</strong></p>
<p>match出来也许1000个doc，其实用户大部分情况下是分页查询的，所以可能最多只会看前几页，比如一页是10条，最多也许就看5页，就是50条<br>proximity match只要对前50个doc进行slop移动去匹配，去贡献自己的分数即可，不需要对全部1000个doc都去进行计算和贡献分数</p>
<p>GET &#x2F;forum&#x2F;article&#x2F;_search<br>{<br>  “query”: {<br>    “match”: {<br>      “content”: “java spark”<br>    }<br>  },<br>  “rescore”: {<br>    “window_size”: 50,<br>    “query”: {<br>      “rescore_query”: {<br>        “match_phrase”: {<br>          “content”: {<br>            “query”: “java spark”,<br>            “slop”: 50<br>          }<br>        }<br>      }<br>    }<br>  }<br>}</p>
<p>扩展</p>
<p>quick brown f</p>
<p>分词不会识别f，所以使用不了match_pharse</p>
<p>可以使用match_phrase_prefix:查找分词前缀的方法（f在fox中是属于前缀，所以可以识别）</p>
<p>match_bool_prefix查询中的quick,brown,f是无序的。</p>
<p>bool代表无序，随机组合，也就代表着should</p>
<p>GET &#x2F;test-match&#x2F;_search<br>{<br>  “query”: {<br>    “bool” : {<br>      “should”: [<br>        { “term”: { “title”: “quick” }},<br>        { “term”: { “title”: “brown” }},<br>        { “prefix”: { “title”: “f”}}<br>      ]<br>    }<br>  }<br>}</p>
<p><img src="C:\Users\JT\AppData\Roaming\Typora\typora-user-images\image-20221018102653316.png" alt="image-20221018102653316"></p>
<p>multi_match</p>
<p>一个字符串在多个字段进行匹配，如在可以查询公司名、职位名字段进行查询</p>
<p><img src="C:\Users\JT\AppData\Roaming\Typora\typora-user-images\image-20221018102840265.png" alt="image-20221018102840265"></p>
<h3 id="2-query-string类型"><a href="#2-query-string类型" class="headerlink" title="2.query string类型"></a>2.query string类型</h3><p>使用运算符（AND | OR | NOT <strong>必须是全大写</strong>）来解析提供的字符串</p>
<p><img src="C:\Users\JT\AppData\Roaming\Typora\typora-user-images\image-20221018103217153.png" alt="image-20221018103217153"></p>
<p>本质上查询这四个分词（term）or的结果而已</p>
<p>simple_query_string <strong>类似于</strong>query_string <strong>，但是会忽略错误的语法，永远不会引发异常，并且会丢弃查询的无效部分。</strong></p>
<p>其中+：AND、-：NOT、|：OR、“”：短语匹配、“\”：近似匹配、* 字词末尾表示前缀查询 -match_phrase_prefix query</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Z52ouZguQulg5GjJIBDj5Q">文章地址</a></p>
<h2 id="DSL查询之Term详解"><a href="#DSL查询之Term详解" class="headerlink" title="DSL查询之Term详解"></a>DSL查询之Term详解</h2><p><img src="https://pdai.tech/_images/db/es/es-dsl-full-text-3.png" alt="img"></p>
<h3 id="字段是否存在-exist"><a href="#字段是否存在-exist" class="headerlink" title="字段是否存在:exist"></a>字段是否存在:exist</h3><h3 id="id查询-ids"><a href="#id查询-ids" class="headerlink" title="id查询:ids"></a>id查询:ids</h3><h3 id="前缀-prefix"><a href="#前缀-prefix" class="headerlink" title="前缀:prefix"></a>前缀:prefix</h3><h3 id="分词匹配-term"><a href="#分词匹配-term" class="headerlink" title="分词匹配:term"></a>分词匹配:term</h3><h3 id="多个分词匹配-terms"><a href="#多个分词匹配-terms" class="headerlink" title="多个分词匹配:terms"></a>多个分词匹配:terms</h3><h3 id="按某个数字字段分词匹配-term-set"><a href="#按某个数字字段分词匹配-term-set" class="headerlink" title="按某个数字字段分词匹配:term set"></a>按某个数字字段分词匹配:term set</h3><p>根据其他字段去匹配查询分词的至少匹配数量，</p>
<p><img src="C:\Users\JT\AppData\Roaming\Typora\typora-user-images\image-20221018110713058.png" alt="image-20221018110713058"></p>
<p><img src="https://pdai.tech/_images/db/es/es-dsl-term-7.png" alt="img"></p>
<p>在required_matches字段中设置了最少匹配字段的矢量，所以查询出来的文档匹配分词数量至少为2</p>
<h3 id="范围-range"><a href="#范围-range" class="headerlink" title="范围:range"></a>范围:range</h3><h3 id="模糊匹配-fuzzy"><a href="#模糊匹配-fuzzy" class="headerlink" title="模糊匹配:fuzzy"></a>模糊匹配:fuzzy</h3><h3 id="通配符-wildcard"><a href="#通配符-wildcard" class="headerlink" title="通配符:wildcard"></a>通配符:wildcard</h3><h2 id="聚合的引入"><a href="#聚合的引入" class="headerlink" title="聚合的引入"></a>聚合的引入</h2><p><strong>桶</strong>在概念上类似于 （<code>GROUP BY</code>），而<strong>指标</strong>则类似于 <code>COUNT()</code> 、 <code>SUM()</code> 、 <code>MAX()</code> 等统计方法。</p>
<p>进而引入了两个概念：</p>
<ul>
<li><strong>桶（Buckets）</strong> 满足特定条件的文档的集合</li>
<li><strong>指标（Metrics）</strong> 对桶内的文档进行统计计算</li>
</ul>
<p>所以ElasticSearch包含3种聚合（Aggregation)方式</p>
<ul>
<li><p><strong>桶聚合（Bucket Aggregation)</strong> - 本文中详解</p>
</li>
<li><p><strong>指标聚合（Metric Aggregation)</strong> - 下文中讲解</p>
</li>
<li><p>管道聚合（Pipline Aggregation)</p>
<p> - 再下一篇讲解</p>
<ul>
<li>聚合管道化，简单而言就是上一个聚合的结果成为下个聚合的输入；</li>
</ul>
</li>
</ul>
<p>（PS:桶聚合本质上是一种特殊的指标聚合，它的聚合指标就是数据的条数count)</p>
<h3 id="如何理解Bucket聚合"><a href="#如何理解Bucket聚合" class="headerlink" title="如何理解Bucket聚合"></a>如何理解Bucket聚合</h3><p><img src="https://pdai.tech/_images/db/es/es-agg-bucket-1.png" alt="img"></p>
<p>桶聚合包含了对流程控制的聚合、对特殊类型字段的聚合、对特殊功能的聚合</p>
<p>单聚合</p>
<p><img src="C:\Users\JT\AppData\Roaming\Typora\typora-user-images\image-20221018112630922.png" alt="image-20221018112630922"></p>
<p>多个聚合</p>
<p><img src="C:\Users\JT\AppData\Roaming\Typora\typora-user-images\image-20221018112727804.png" alt="image-20221018112727804"></p>
<p>嵌套聚合</p>
<p><img src="C:\Users\JT\AppData\Roaming\Typora\typora-user-images\image-20221018112740199.png" alt="image-20221018112740199"></p>
<h3 id="动态脚本的聚合"><a href="#动态脚本的聚合" class="headerlink" title="动态脚本的聚合"></a>动态脚本的聚合</h3><p>这个例子告诉你，ElasticSearch还支持一些基于脚本（生成运行时的字段）的复杂的动态聚合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">GET /test-agg-cars/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;runtime_mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;make.length&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;long&quot;</span>,</span><br><span class="line">      <span class="string">&quot;script&quot;</span>: <span class="string">&quot;emit(doc[&#x27;make.keyword&#x27;].value.length())&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;size&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="string">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;make_length&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;histogram&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;interval&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;field&quot;</span>: <span class="string">&quot;make.length&quot;</span> <span class="comment">//运行时脚本名</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按模块划分桶聚合</p>
<h3 id="按桶分类学习"><a href="#按桶分类学习" class="headerlink" title="按桶分类学习"></a>按桶分类学习</h3><h4 id="前置条件的过滤：filter"><a href="#前置条件的过滤：filter" class="headerlink" title="前置条件的过滤：filter"></a>前置条件的过滤：filter</h4><p>本质是：先过滤后聚合</p>
<p><img src="C:\Users\JT\AppData\Roaming\Typora\typora-user-images\image-20221018115315936.png" alt="image-20221018115315936"></p>
<h5 id="在filter-基础上加-post-filter-场景"><a href="#在filter-基础上加-post-filter-场景" class="headerlink" title="在filter 基础上加 post_filter 场景"></a>在filter 基础上加 post_filter 场景</h5><p><img src="C:\Users\JT\AppData\Roaming\Typora\typora-user-images\image-20221018115219395.png" alt="image-20221018115219395"></p>
<p>post filter：是在检索+聚合之后，对已有数据再次进行的过滤。所以，不影响聚合结果,只影响检索结果。</p>
<h5 id="对Filter进行分组聚合，分成三个组，排除在Info和warn分组外的other组。"><a href="#对Filter进行分组聚合，分成三个组，排除在Info和warn分组外的other组。" class="headerlink" title="对Filter进行分组聚合，分成三个组，排除在Info和warn分组外的other组。"></a>对Filter进行分组聚合，分成三个组，排除在Info和warn分组外的other组。</h5><p><img src="C:\Users\JT\AppData\Roaming\Typora\typora-user-images\image-20221018134225774.png" alt="image-20221018134225774"></p>
<h5 id="对number类型聚合：Range"><a href="#对number类型聚合：Range" class="headerlink" title="对number类型聚合：Range"></a>对number类型聚合：Range</h5><h5 id="对IP类型聚合：IP-Range"><a href="#对IP类型聚合：IP-Range" class="headerlink" title="对IP类型聚合：IP Range"></a>对IP类型聚合：IP Range</h5><h5 id="对日期类型聚合：Date-Range"><a href="#对日期类型聚合：Date-Range" class="headerlink" title="对日期类型聚合：Date Range"></a>对日期类型聚合：Date Range</h5><h5 id="对柱状图功能：Histrogram（特殊功能）"><a href="#对柱状图功能：Histrogram（特殊功能）" class="headerlink" title="对柱状图功能：Histrogram（特殊功能）"></a>对柱状图功能：Histrogram（特殊功能）</h5><h4 id="度量聚合"><a href="#度量聚合" class="headerlink" title="度量聚合"></a>度量聚合</h4><h4 id="管道聚合"><a href="#管道聚合" class="headerlink" title="管道聚合"></a>管道聚合</h4><h2 id="ES原理初步认知"><a href="#ES原理初步认知" class="headerlink" title="ES原理初步认知"></a>ES原理初步认知</h2><p>认识Lucene之前 </p>
<p><img src="D:\typora文件\image\lucene来源.jpg"></p>
<p><strong>全文搜索：</strong>（先对数据进行创建索引，然后再搜索）</p>
<p>将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对此有一定结构的数据进行搜索，从而达到搜索相对较快的目的。</p>
<p>这种方式就构成了全文检索的基本思路。这部分从非结构化数据中提取出的然后重新组织的信息，我们称之为索引。</p>
<p>这种方式的主要工作量在前期索引的创建，但是对于后期搜索却是快速高效的。</p>
<h3 id="认识Lucene"><a href="#认识Lucene" class="headerlink" title="认识Lucene"></a>认识Lucene</h3><p>Lucene是一个Apache的一个工具包，并不是一个完整的全文检索引擎。</p>
<p>Elasticsearch底层依赖于Lucene，而Lucene能实现全文检索主要还是因为它实现了倒排索引的查询结构。</p>
<p>创建倒排索引原理</p>
<p>1、通过分词器将文档进行分词，创建词条的排序列表（词典）</p>
<p>2、列出词条所出现的文档id（倒排索引项），组成倒排列表</p>
<p>3、倒排列表的集合组成倒排文件，倒排文件与词典组成倒排索引</p>
<p>核心术语详解</p>
<ul>
<li><strong>倒排表（Post list）：</strong>一个文档通常由多个词组成，倒排表记录的是某个词在哪些文档里出现过以及出现的位置。每条记录称为一个倒排项（Posting）。倒排表记录的不单是文档编号，还存储了词频等信息。</li>
<li><strong>倒排文件（Inverted File）：</strong>所有单词的倒排列表往往顺序地存储在磁盘的某个文件里，这个文件被称之为倒排文件，倒排文件是存储倒排索引的物理文件。</li>
</ul>
<p>词典和倒排表是 Lucene 中很重要的两种数据结构，是实现快速检索的重要基石。词典和倒排文件是分两部分存储的，<strong>词典在内存</strong>中而<strong>倒排文件存储在磁盘</strong>。</p>
<p><strong>深入理解</strong></p>
<ul>
<li>Java is the best programming language.</li>
<li>PHP is the best programming language.</li>
<li>Javascript is the best programming language.</li>
</ul>
<p><img src="D:\typora文件\image\image-20221020104046152.png"></p>
<h2 id="ES核心概念"><a href="#ES核心概念" class="headerlink" title="ES核心概念"></a>ES核心概念</h2><p>ES 通过对 Lucene 的封装，隐藏了 Lucene 的复杂性，提供RESTful API，并且也不仅仅只是一个全文搜索引擎。</p>
<p>它可以被下面这样准确的形容：</p>
<ul>
<li>一个分布式的实时文档存储，每个字段可以被索引与搜索。</li>
<li>一个分布式实时分析搜索引擎。</li>
<li>能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据。</li>
</ul>
<p>官网对 Elasticsearch 的介绍是 Elasticsearch 是一个分布式、可扩展、近实时的搜索与数据分析引擎。</p>
<h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><p>ES 集群由一个或多个 Elasticsearch 节点组成，每个节点配置相同的集群名即可加入集群，默认值为 “elasticsearch”。</p>
<p>节点通过 node.name 来设置节点名称，如果不设置则在启动时给节点分配一个随机通用唯一标识符作为名称。</p>
<h4 id="发现机制"><a href="#发现机制" class="headerlink" title="发现机制"></a>发现机制</h4><p>Zen Discovery 是 Elasticsearch 的发现模块（发现模块的职责是发现集群中的节点以及选举 Master 节点）</p>
<p>它提供单播和基于文件的发现，并且可以通过插件扩展为支持云环境和其他形式的发现。</p>
<p>Zen Discovery 与其他模块集成，例如，节点之间的所有通信都使用 Transport 模块完成。节点通过 Ping 的方式查找其他节点实现发现机制。</p>
<p>Elasticsearch 默认被配置为使用单播发现，以防止节点无意中加入集群。只有在同一台机器上运行的节点才会自动组成集群。</p>
<p>如果集群的节点运行在不同的机器上，使用单播，你可以为 Elasticsearch 提供一些它应该去尝试连接的节点列表（单播列表）。</p>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43742184/article/details/112311031">文章地址</a></p>
<p>在 es 中，一个节点加入集群有两种传统方式：多播（组播）、单播。</p>
<h5 id="组播"><a href="#组播" class="headerlink" title="组播"></a>组播</h5><p>将网络中同一业务类型主机进行了逻辑上的分组，进行数据收发的时候其数据仅仅在同一分组中进行，其他的主机没有加入此分组不能收发对应的数据。</p>
<p>也可以称为“组播”，将网络中同一业务类型主机进行了逻辑上的分组，进行数据收发的时候其数据仅仅在同一分组中进行，其他的主机没有加入此分组不能收发对应的数据。<br>网上视频会议、视频点播比较时候使用多播。因为如果用单播，逐个节点传输，有多少个目标节点就会有多少次传送过程，这样显然效率极低，是不可取的；如果采用不区分目标，全部发送的广播方式，虽然一次可以传送完数据，但是显然达不到区分特定数据接收对象的目的。<br>采用多播方式，既可以实现一次传送所有目标节点的数据，也可以达到只对特定对象传送数据的目的。<br>IP网络的多播一般通过多播IP来实现。多播IP地址就是D类IP地址，即224.0.0.0至239.255.255.255之间的IP地址。</p>
<h5 id="单播"><a href="#单播" class="headerlink" title="单播"></a>单播</h5><p>单播类似于 “口口相传”。如果现在有7个不同集群的节点，其中2个节点的地址在 Node2  节点的配置中，4个节点的地址在 Node3 节点的配置中，而 Node2 与 Node3 节点的地址在 C 节点的配置中，那么 Node1 节点就会知道 6 + Node2+ Node3 节点的地址，并通过 cluster.name 选择集群加入。</p>
<p>与组播比起来，单播会更安全、应用的也更广泛</p>
<p><img src="C:\Users\JT\AppData\Roaming\Typora\typora-user-images\image-20221020135133689.png" alt="image-20221020135133689"></p>
<h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>单播模式<br>节点向指定的主机发送单播请求，配置如下：<br>discovery.zen.ping.multicast.enabled: false （多播模式设置false）</p>
<p>多播模式<br>意思就是说，你只需要在每个节点配置好了集群名称，节点名称，互相通信的节点会根据es自定义的服务发现协议去按照多播的方式来寻找网络上配置在同样集群内的节点。</p>
<p>discovery.zen.ping.multicast.enabled: true 这个设置把组播的自动发现给关闭了，为了防止其他机器上的节点自动连入。<br>discovery.zen.fd.ping_timeout: 100s<br>discovery.zen.ping.timeout: 100s<br>discovery.zen.minimum_master_nodes: 2 &#x2F;&#x2F;这个设置为了避免脑裂。比如3个节点的集群，如果设置为2，那么当一台节点脱离后，不会自动成为master。<br>discovery.zen.ping.unicast.hosts: [“172.31.26.200”] &#x2F;&#x2F;这个设置了自动发现的节点。 </p>
<p><strong>疑点</strong></p>
<p><em>当一个节点联系到单播列表中的成员时，它就会得到整个集群所有节点的状态，然后它会联系 Master 节点，并加入集群。</em></p>
<p><em>这意味着单播列表不需要包含集群中的所有节点， 它只是需要足够的节点，当一个新节点联系上其中一个并且说上话就可以了。</em></p>
<p><em>如果你使用 Master 候选节点作为单播列表，你只要列出三个就可以了。这个配置在 elasticsearch.yml 文件中：</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">discovery.zen.ping.unicast.hosts: [<span class="string">&quot;host1&quot;</span>, <span class="string">&quot;host2:port&quot;</span>] </span><br></pre></td></tr></table></figure>

<h4 id="master选举谁发起，什么时候发起？"><a href="#master选举谁发起，什么时候发起？" class="headerlink" title="master选举谁发起，什么时候发起？"></a>master选举谁发起，什么时候发起？</h4><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/tOAfwG6Ctkqo28iG88E0yA">文章地址</a></p>
<p>master选举当然是由master-eligible节点发起，当一个master-eligible节点发现满足以下条件时发起选举：</p>
<ol>
<li>该master-eligible节点的当前状态不是master。</li>
<li>该master-eligible节点通过Zen Discovery模块的ping操作询问其已知的集群其他节点，没有任何节点连接到master。</li>
<li>包括本节点在内，当前已有超过minimum_master_nodes个节点没有连接到master。</li>
</ol>
<p>即当一个节点发现包括自己在内的多数派的master-eligible节点认为集群没有master时，就可以发起master选举</p>
<h4 id="ES服务发现以及选举Master流程（zen-discovery）"><a href="#ES服务发现以及选举Master流程（zen-discovery）" class="headerlink" title="ES服务发现以及选举Master流程（zen discovery）"></a>ES服务发现以及选举Master流程（zen discovery）</h4><p>1、节点启动后先 Ping ，如果<code>discovery.zen.ping.unicast.hosts</code>有设置，则 Ping 设置中的 Host ，否则尝试 ping localhost 的几个端口。</p>
<p>2、Ping 的 Response 包含该节点的基本信息以及该节点认为的 Master 节点。</p>
<p>3、按照ID的字典序排序选出各节点认为的Master，若没有，则在所有节点中按照上规则选举。</p>
<p>4、若是没有达到选举的最小节点数，则循环1-4过程，直到可以选举，最终肯定会选出举一个Master。</p>
<p>5、若已经有Master节点，但是最小节点数不满足，则等待节点数满足后提供服务。</p>
<p>Es支持任意数目集群，不能像 Zookeeper 那样限制节点必须是奇数，也就无法用投票的机制来选主，所以它通过规则来选举Master</p>
<p><strong>只要所有的节点都遵循同样的规则，得到的信息都是对等的，选出来的主节点肯定是一致的。</strong></p>
<p>但分布式系统的问题就出在信息不对等的情况下选举Master很容易出现脑裂（Split-Brain）的问题。</p>
<p>大多数解决方案就是设置一个 Quorum 值，要求可用节点必须大于 Quorum（多数派），才能对外提供服务。</p>
<p>而 Elasticsearch 中，这个 Quorum 的配置就是<code>discovery.zen.minimum_master_nodes</code>&#x3D;候选Master&#x2F;2 +1。</p>
<h3 id="节点的角色"><a href="#节点的角色" class="headerlink" title="节点的角色"></a>节点的角色</h3><p>每个节点既可以是候选主节点也可以是数据节点，通过在配置文件<br>..&#x2F;config&#x2F;elasticsearch.yml 中设置即可，默认都为 true。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node.master: true //是否候选主节点 </span><br><span class="line">node.data: true //是否数据节点</span><br></pre></td></tr></table></figure>

<h4 id="数据节点"><a href="#数据节点" class="headerlink" title="数据节点"></a>数据节点</h4><p>负责数据的存储和相关的操作，例如对数据进行增、删、改、查和聚合等操作，所以数据节点（Data 节点）对机器配置要求比较高，对 CPU、内存和 I&#x2F;O 的消耗很大。</p>
<p>通常随着集群的扩大，需要增加更多的数据节点来提高性能和可用性。</p>
<h4 id="候选主节点"><a href="#候选主节点" class="headerlink" title="候选主节点"></a>候选主节点</h4><p>可以被选举为主节点（Master 节点），集群中只有候选主节点才有选举权和被选举权，其他节点不参与选举的工作。</p>
<h4 id="主节点"><a href="#主节点" class="headerlink" title="主节点"></a>主节点</h4><p>负责创建索引、删除索引、跟踪哪些节点是群集的一部分，并决定哪些分片分配给相关的节点、追踪集群中节点的状态等，稳定的主节点对集群的健康是非常重要的。</p>
<h4 id="协调节点"><a href="#协调节点" class="headerlink" title="协调节点"></a>协调节点</h4><p>任何一个集群内的node都可以执行任何请求，其会负责将请求转发给对应的node进行处理，这个节点可以作为一个类似proxy的节点，接受请求并进行转发、结果聚合等。</p>
<p><img src="D:\typora文件\image\image-20221020142253466.png" alt="image-20221020142253466"></p>
<p>一个节点既可以是候选主节点也可以是数据节点，但是由于数据节点对 CPU、内存核 I&#x2F;O 消耗都很大。</p>
<p>所以如果某个节点既是数据节点又是主节点，那么可能会对主节点产生影响从而对整个集群的状态产生影响。</p>
<p>因此为了提高集群的健康性，我们应该对 Elasticsearch 集群中的节点做好角色上的划分和隔离。可以使用几个配置较低的机器群作为候选主节点群。</p>
<p>主节点和其他节点之间通过 Ping 的方式互检查，主节点负责 Ping 所有其他节点，判断是否有节点已经挂掉。其他节点也通过 Ping 的方式判断主节点是否处于可用状态。</p>
<h3 id="脑裂"><a href="#脑裂" class="headerlink" title="脑裂"></a>脑裂</h3><h4 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h4><ul>
<li><strong>网络问题：</strong>集群间的网络延迟导致一些节点访问不到 Master，认为 Master 挂掉了从而选举出新的 Master，并对 Master 上的分片和副本标红，分配新的主分片。</li>
<li><strong>节点负载：</strong>主节点的角色既为 Master 又为 Data，访问量较大时可能会导致 ES 停止响应（假死状态）造成大面积延迟，此时其他节点得不到主节点的响应认为主节点挂掉了，会重新选取主节点。</li>
<li><strong>内存回收：</strong>主节点的角色既为 Master 又为 Data，当 Data 节点上的 ES 进程占用的内存较大，引发 JVM 的大规模内存回收，造成 ES 进程失去响应。</li>
</ul>
<h4 id="优化措施"><a href="#优化措施" class="headerlink" title="优化措施"></a>优化措施</h4><p>网络问题方向：增加discovery.zen.ping_timeout 的响应时间</p>
<p>节点负载方向：数据节点与Master角色分离，减轻主节点的负担，防止主节点的假死状态发生</p>
<p>设置选举触发的大多数：discovery.zen.munimum_master_nodes&#x3D;master_eligibel_nodes&#x2F;2+1</p>
<p>这样做既能防止脑裂现象的发生，也能最大限度地提升集群的高可用性，因为只要不少于<code>discovery.zen.munimum_master_nodes</code>个候选节点存活，选举工作就能正常进行。</p>
<p>当小于这个值的时候，无法触发选举行为，集群无法使用，不会造成分片混乱的情况。</p>
<h2 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h2><p>ES 支持 PB 级全文搜索，当索引上的数据量太大的时候，ES 通过水平拆分的方式将一个索引上的数据拆分出来分配到不同的数据块上，拆分出来的数据库块称之为一个分片。</p>
<p>在一个多分片的索引中写入数据时，通过路由来确定具体写入哪一个分片中，所以在创建索引的时候需要指定分片的数量，并且分片的数量一旦确定就不能修改。</p>
<p>分片的数量和下面介绍的副本数量都是可以通过创建索引时的 Settings 来配置，ES 默认为一个索引创建 5 个主分片, 并分别为每个分片创建一个副本。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT /myIndex </span><br><span class="line">&#123;&quot;settings&quot; : &#123;</span><br><span class="line">&quot;number_of_shards&quot; : 5,</span><br><span class="line">&quot;number_of_replicas&quot; : 1</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>ES 通过分片的功能使得索引在规模上和性能上都得到提升，每个分片都是 Lucene 中的一个索引文件，每个分片必须有一个主分片和零到多个副本。</p>
<p><strong>副本（Replicas）</strong></p>
<p>副本就是对分片的 Copy，每个主分片都有一个或多个副本分片，当主分片异常时，副本可以提供数据的查询等操作。</p>
<p>主分片和对应的副本分片是不会在同一个节点上的，所以副本分片数的最大值是 N-1（其中 N 为节点数）。</p>
<p>对文档的新建、索引和删除请求都是写操作，必须在主分片上面完成之后才能被复制到相关的副本分片。</p>
<p>ES 为了提高写入的能力这个过程是并发写的，同时为了解决并发写的过程中数据冲突的问题，ES 通过乐观锁的方式控制，每个文档都有一个<code> _version</code>（版本）号，当文档被修改时版本号递增。</p>
<p>一旦所有的副本分片都报告写成功才会向协调节点报告成功，协调节点向客户端报告成功。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/RQueXibgo0KMj5AtfeIT4j0fw96MQeibSM68kC2X1CVVROdPv5ZWZbA0bwzicfgrSbxKNlhYfc64bMe8LMG5kYWkg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>从上图可以看出为了达到高可用，Master 节点会避免将主分片和副本分片放在同一个节点上。</p>
<p>假设这时节点 Node1 服务宕机了或者网络不可用了，那么主节点上主分片 S0 也就不可用了。</p>
<p>幸运的是还存在另外两个节点能正常工作，这时 ES 会重新选举新的主节点，而且这两个节点上存在我们所需要的 S0 的所有数据。</p>
<p>我们会将 S0 的副本分片提升为主分片，这个提升主分片的过程是瞬间发生的。此时集群的状态将会为 Yellow。</p>
<p>为什么我们集群状态是 Yellow 而不是 Green 呢？虽然我们拥有所有的 2 个主分片，但是同时设置了每个主分片需要对应两份副本分片，而此时只存在一份副本分片。所以集群不能为 Green 的状态。</p>
<p>如果我们同样关闭了 Node2 ，我们的程序依然可以保持在不丢失任何数据的情况下运行，因为 Node3 为每一个分片都保留着一份副本。</p>
<p>如果我们重新启动 Node1 ，集群可以将缺失的副本分片再次进行分配，那么集群的状态又将恢复到原来的正常状态。</p>
<p>如果 Node1 依然拥有着之前的分片，它将尝试去重用它们，只不过这时 Node1 节点上的分片不再是主分片而是副本分片了，如果期间有更改的数据只需要从主分片上复制修改的数据文件即可。</p>
<p><strong>小结：</strong></p>
<ul>
<li>将数据分片是为了提高可处理数据的容量和易于进行水平扩展，为分片做副本是为了提高集群的稳定性和提高并发量。</li>
<li>副本是乘法，越多消耗越大，但也越保险。分片是除法，分片越多，单分片数据就越少也越分散。</li>
<li>副本越多，集群的可用性就越高，但是由于每个分片都相当于一个 Lucene 的索引文件，会占用一定的文件句柄、内存及 CPU。并且分片间的数据同步也会占用一定的网络带宽，所以索引的分片数和副本数也不是越多越好。</li>
</ul>
<h2 id="映射（Mapping）"><a href="#映射（Mapping）" class="headerlink" title="映射（Mapping）"></a>映射（Mapping）</h2><p>动态映射：对字段类型根据数据格式自动识别的映射</p>
<p>静态映射或显示映射：创建索引时具体定义字段类型</p>
<p>ES（v6.8）中字段数据类型主要有以下几类：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/RQueXibgo0KMj5AtfeIT4j0fw96MQeibSMJYIdstfIh81rIJyGPYktyAN8uk7xC7qCHIoCYBFmlaYRlue5WMBZBw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>Text 用于索引全文值的字段，例如电子邮件正文或产品说明。<strong>这些字段是被分词的</strong>，它们通过分词器传递 ，以在被索引之前将字符串转换为单个术语的列表。</p>
<p>分析过程允许 Elasticsearch 搜索单个单词中每个完整的文本字段。文本字段不用于排序，很少用于聚合。</p>
<p>Keyword 用于索引结构化内容的字段，例如电子邮件地址，主机名，状态代码，邮政编码或标签。它们通常<strong>用于过滤，排序，和聚合</strong>。Keyword 字段只能按其确切值进行搜索。</p>
<p>通过对字段类型的了解我们知道有些字段需要明确定义的，例如某个字段是 Text 类型还是 Keyword 类型差别是很大的，时间字段也许我们需要指定它的时间格式，还有一些字段我们需要指定特定的分词器等等。</p>
<p>如果采用动态映射是不能精确做到这些的，自动识别常常会与我们期望的有些差异。</p>
<p>所以创建索引的时候一个完整的格式应该是指定分片和副本数以及 Mapping 的定义，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index </span><br><span class="line">&#123;&quot;settings&quot; : &#123;</span><br><span class="line">&quot;number_of_shards&quot; : 5,</span><br><span class="line">&quot;number_of_replicas&quot; : 1</span><br><span class="line">&#125;&quot;mappings&quot;: &#123;</span><br><span class="line">&quot;_doc&quot;: &#123;</span><br><span class="line">&quot;properties&quot;: &#123;</span><br><span class="line">&quot;title&quot;: &#123; &quot;type&quot;: &quot;text&quot; &#125;,</span><br><span class="line">&quot;name&quot;: &#123; &quot;type&quot;: &quot;text&quot; &#125;,</span><br><span class="line">&quot;age&quot;: &#123; &quot;type&quot;: &quot;integer&quot; &#125;,</span><br><span class="line">&quot;created&quot;: &#123;</span><br><span class="line">&quot;type&quot;: &quot;date&quot;,</span><br><span class="line">&quot;format&quot;: &quot;strict_date_optional_time||epoch_millis&quot;</span><br><span class="line">&#125;&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ES初步认识"><a href="#ES初步认识" class="headerlink" title="ES初步认识"></a>ES初步认识</h1><p>ES原理</p>
<p>集群-Node-shard-Lucene Index</p>
<h2 id="Lucene原理"><a href="#Lucene原理" class="headerlink" title="Lucene原理"></a>Lucene原理</h2><p>Lucene Index 以段（segment存储）</p>
<p><img src="D:\typora文件\image\es-th-1-6.png" alt="img"></p>
<p>Segment中存在四种数据结构</p>
<p>1、倒排索引（inverted Index）</p>
<p>2、存储字段（stored Fields）</p>
<p>3、文档数据（Document Values）</p>
<p>4、缓存（cache）</p>
<h3 id="Inverted-Index"><a href="#Inverted-Index" class="headerlink" title="Inverted Index"></a>Inverted Index</h3><p><img src="D:\typora文件\image\es-th-1-8.png" alt="img"></p>
<p>Inverted Index主要包括两部分：</p>
<ul>
<li>一个有序的数据字典Dictionary（包括单词Term和它出现的频率）。</li>
<li>与单词Term对应的Postings（即存在这个单词的文件）。</li>
</ul>
<h3 id="Stored-Field字段查找"><a href="#Stored-Field字段查找" class="headerlink" title="Stored Field字段查找"></a>Stored Field字段查找</h3><p>当我们想要查找<strong>包含某个特定标题内容的文件</strong>时，Inverted Index就不能很好的解决这个问题，所以Lucene提供了另外一种数据结构Stored Fields来解决这个问题。本质上，Stored Fields是一个简单的键值对key-value。默认情况下，ElasticSearch会存储整个文件的JSON source。</p>
<p><img src="https://pdai.tech/_images/db/es/es-th-1-15.png" alt="img"></p>
<h3 id="Document-Values为了排序，聚合"><a href="#Document-Values为了排序，聚合" class="headerlink" title="Document Values为了排序，聚合"></a>Document Values为了排序，聚合</h3><p>即使这样，我们发现以上结构仍然无法解决诸如：排序、聚合、facet，因为我们可能会要读取大量不需要的信息。</p>
<p>所以，另一种数据结构解决了此种问题：Document Values。这种结构本质上就是一个列式的存储，它高度优化了具有相同类型的数据的存储结构。</p>
<p><img src="D:\typora文件\image\es-th-1-16.png" alt="img"></p>
<p>为了提高效率，ElasticSearch可以将索引下某一个Document Value全部读取到内存中进行操作，这大大提升访问速度，但是也同时会消耗掉大量的内存空间。</p>
<p>总之，这些数据结构Inverted Index、Stored Fields、Document Values及其缓存，都在segment内部。</p>
<h3 id="搜索发生时"><a href="#搜索发生时" class="headerlink" title="搜索发生时"></a>搜索发生时</h3><p>搜索时，Lucene会搜索所有的segment然后将每个segment的搜索结果返回，最后合并呈现给客户。</p>
<p>Lucene的一些特性使得这个过程非常重要：</p>
<ul>
<li>Segments是不可变的（immutable）<ul>
<li>Delete? 当删除发生时，Lucene做的只是将其标志位置为删除，但是文件还是会在它原来的地方，不会发生改变</li>
<li>Update? 所以对于更新来说，本质上它做的工作是：先删除，然后重新索引（Re-index）</li>
</ul>
</li>
<li>随处可见的压缩<ul>
<li>Lucene非常擅长压缩数据，基本上所有教科书上的压缩方式，都能在Lucene中找到。</li>
</ul>
</li>
<li>缓存所有的所有<ul>
<li>Lucene也会将所有的信息做缓存，这大大提高了它的查询效率。</li>
</ul>
</li>
</ul>
<h3 id="缓存的故事"><a href="#缓存的故事" class="headerlink" title="缓存的故事"></a>缓存的故事</h3><p>当ElasticSearch创建索引文件，会为文件建立相应的缓存，并且会定期（每秒）刷新这些数据，显示segment，然后这些文件就可以被搜索到。</p>
<p><img src="D:\typora文件\image\es-th-1-17.png" alt="img"></p>
<p>随着时间的增加，我们会有很多segments，</p>
<p><img src="D:\typora文件\image\es-th-1-18.png" alt="img"></p>
<p>所以ElasticSearch会将这些segment合并，在这个过程中，segment会最终被删除掉</p>
<p><img src="D:\typora文件\image\es-th-1-19.png" alt="img"></p>
<p>这就是为什么增加文件可能会使索引所占空间变小，它会引起merge，从而可能会有更多的压缩。</p>
<ul>
<li><strong>举个栗子</strong></li>
</ul>
<p>有两个segment将会merge</p>
<p><img src="D:\typora文件\image\es-th-1-20.png" alt="img"></p>
<p>这两个segment最终会被删除，然后合并成一个新的segment</p>
<p><img src="D:\typora文件\image\es-th-1-21.png" alt="img"></p>
<p>这时这个新的segment在缓存中处于cold状态，但是大多数segment仍然保持不变，处于warm状态。</p>
<p>以上场景经常在Lucene Index内部发生的。</p>
<p><img src="D:\typora文件\image\es-th-1-22.png" alt="img"></p>
<h3 id="在Shard中搜索"><a href="#在Shard中搜索" class="headerlink" title="在Shard中搜索"></a>在Shard中搜索</h3><p>ElasticSearch从Shard中搜索的过程与Lucene Segment中搜索的过程类似。</p>
<p><img src="D:\typora文件\image\es-th-1-23.png" alt="img"></p>
<p>与在Lucene Segment中搜索不同的是，Shard可能是分布在不同Node上的，所以在搜索与返回结果时，所有的信息都会通过网络传输。</p>
<p>需要注意的是：</p>
<p>1次搜索查找2个shard ＝ 2次分别搜索shard</p>
<p><img src="D:\typora文件\image\es-th-1-24.png" alt="img"></p>
<ul>
<li><strong>对于日志文件的处理</strong></li>
</ul>
<p>当我们想搜索特定日期产生的日志时，通过根据时间戳对日志文件进行分块与索引，会极大提高搜索效率。</p>
<p>当我们想要删除旧的数据时也非常方便，只需删除老的索引即可。</p>
<p><img src="D:\typora文件\image\es-th-1-25.png" alt="img"></p>
<p>在上种情况下，每个index有两个shards</p>
<ul>
<li><strong>如何Scale</strong></li>
</ul>
<p><img src="D:\typora文件\image\es-th-1-26.png" alt="img"></p>
<p>shard不会进行更进一步的拆分，但是shard可能会被转移到不同节点上</p>
<p><img src="D:\typora文件\image\es-th-1-27.png" alt="img"></p>
<p>所以，如果当集群节点压力增长到一定的程度，我们可能会考虑增加新的节点，这就会要求我们对所有数据进行重新索引，这是我们不太希望看到的，所以我们需要在规划的时候就考虑清楚，如何去平衡足够多的节点与不足节点之间的关系。</p>
<ul>
<li>节点分配与Shard优化<ul>
<li>为更重要的数据索引节点，分配性能更好的机器</li>
<li>确保每个shard都有副本信息replica</li>
</ul>
</li>
</ul>
<p><img src="D:\typora文件\image\es-th-1-28.png" alt="img"></p>
<ul>
<li><strong>路由Routing</strong></li>
</ul>
<p>每个节点都持有一份路由表，所以当请求到任何一个节点时，ElasticSearch都有能力将请求转发到期望节点的shard进一步处理。</p>
<p><img src="D:\typora文件\image\es-th-1-29.png" alt="img"></p>
<h3 id="请求的过程"><a href="#请求的过程" class="headerlink" title="请求的过程"></a>请求的过程</h3><p>1、协调节点接收请求，根据索引信息查找到分片，请求会被转发到节点。</p>
<p><strong>删除或者更新请求</strong></p>
<p>Node 3 在主分片上面执行请求。如果成功了，它将请求并行转发到 Node 1 和 Node 2 的副本分片上。一旦所有的副本分片都报告成功, Node 3 将向协调节点报告成功，协调节点向客户端报告成功。</p>
<p>2、ES将Query查询转化为Lucene Query</p>
<p>3、在所有Segment中查询</p>
<p>4、Lucene缓存Filter条件，但是不缓存Query条件，如果相同的Query重复执行，应用程序自己需要做缓存</p>
<p>​	1）filters可以在任何时候使用 2) query只有在需要score的时候才使用</p>
<p>5、搜索结束之后，结果会沿着下行的路径向上逐层返回。合并Segment，协调节点合并分片、返回用户请求结果</p>
<h1 id="Es整体结构"><a href="#Es整体结构" class="headerlink" title="Es整体结构"></a>Es整体结构</h1><p><img src="D:\typora文件\image\es-th-2-3.png" alt="img"></p>
<ul>
<li>一个 ES Index 在集群模式下，有多个 Node （节点）组成。每个节点就是 ES 的Instance (实例)。</li>
<li>每个节点上会有多个 shard （分片）， P1 P2 是主分片, R1 R2 是副本分片</li>
<li>每个分片上对应着就是一个 Lucene Index（底层索引文件）</li>
<li>Lucene Index 是一个统称<ul>
<li>由多个 Segment （段文件，就是倒排索引）组成。每个段文件存储着就是 Doc 文档。</li>
<li>commit point记录了所有 segments 的信息</li>
</ul>
</li>
</ul>
<h2 id="补充-Lucene索引结构"><a href="#补充-Lucene索引结构" class="headerlink" title="补充:Lucene索引结构"></a>补充:Lucene索引结构</h2><blockquote>
<p>上图中Lucene的索引结构中有哪些文件呢？</p>
</blockquote>
<p><img src="https://pdai.tech/_images/db/es/es-th-2-2.png" alt="img"></p>
<p>文件的关系如下：</p>
<p><img src="https://pdai.tech/_images/db/es/es-th-3-2.jpeg" alt="img"></p>
<h2 id="补充-Lucene处理流程"><a href="#补充-Lucene处理流程" class="headerlink" title="补充:Lucene处理流程"></a>补充:Lucene处理流程</h2><blockquote>
<p>上文图解过程，还需要理解Lucene处理流程, 这将帮助你更好的索引文档和搜索文档。</p>
</blockquote>
<p><img src="https://pdai.tech/_images/db/es/es-th-3-21.jpeg" alt="img"></p>
<p>创建索引的过程：</p>
<ul>
<li>准备待索引的原文档，数据来源可能是文件、数据库或网络</li>
<li>对文档的内容进行分词组件处理，形成一系列的Term</li>
<li>索引组件对文档和Term处理，形成字典和倒排表</li>
</ul>
<p>搜索索引的过程：</p>
<ul>
<li>对查询语句进行分词处理，形成一系列Term</li>
<li>根据倒排索引表查找出包含Term的文档，并进行合并形成符合结果的文档集</li>
<li>比对查询语句与各个文档相关性得分，并按照得分高低返回</li>
</ul>
<h1 id="ES索引文档详解"><a href="#ES索引文档详解" class="headerlink" title="ES索引文档详解"></a>ES索引文档详解</h1><h3 id="单个文档"><a href="#单个文档" class="headerlink" title="单个文档"></a>单个文档</h3><p>新建单个文档所需要的步骤顺序：</p>
<p><img src="D:\typora文件\image\es-th-2-4.png" alt="img"></p>
<ol>
<li>客户端向 Node 1 发送新建、索引或者删除请求。</li>
<li>节点使用文档的 _id 确定文档属于分片 0 。请求会被转发到 Node 3，因为分片 0 的主分片目前被分配在 Node 3 上。</li>
<li>Node 3 在主分片上面执行请求。如果成功了，它将请求并行转发到 Node 1 和 Node 2 的副本分片上。一旦所有的副本分片都报告成功, Node 3 将向协调节点报告成功，协调节点向客户端报告成功。</li>
</ol>
<h3 id="多个文档"><a href="#多个文档" class="headerlink" title="多个文档"></a>多个文档</h3><p>使用 bulk 修改多个文档步骤顺序：</p>
<p><img src="https://pdai.tech/_images/db/es/es-th-2-23.png" alt="img"></p>
<ol>
<li>客户端向主节点Node1发送 bulk 请求。</li>
<li>Node 1 为每个节点创建一个批量请求，并将这些请求并行转发到每个包含主分片的节点主机。</li>
<li>主分片一个接一个按顺序执行每个操作。当每个操作成功时，主分片并行转发新文档（或删除）到副本分片，然后执行下一个操作。 一旦所有的副本分片报告所有操作成功，该节点将向协调节点报告成功，协调节点将这些响应收集整理并返回给客户端。</li>
</ol>
<h3 id="整体的索引流程"><a href="#整体的索引流程" class="headerlink" title="整体的索引流程"></a>整体的索引流程</h3><p><img src="D:\typora文件\image\es-th-2-5.jpeg" alt="img"></p>
<ul>
<li>协调节点默认使用文档ID参与计算（也支持通过routing），以便为路由提供合适的分片。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shard = <span class="built_in">hash</span>(文档ID) % (主分片数)  </span><br></pre></td></tr></table></figure>

<ul>
<li>分片接收到协调节点转发的请求会先写入到内存，定时刷新写入到文件缓存，这个从Momery Buffer到Filesystem Cache的过程就叫做refresh；</li>
<li>当然在某些情况下，存在Momery Buffer和Filesystem Cache的数据可能会丢失，ES是通过translog的机制来保证数据的可靠性的。其实现机制是接收到请求后，同时也会写入到translog中，当Filesystem cache中的数据写入到磁盘中时，才会清除掉，这个过程叫做flush。</li>
<li>在flush过程中，内存中的缓冲将被清除，内容被写入一个新段，段的fsync将创建一个新的提交点，并将内容刷新到磁盘，旧的translog将被删除并开始一个新的translog。 flush触发的时机是定时触发（默认30分钟）或者translog变得太大（默认为512M）时。</li>
</ul>
<p><img src="D:\typora文件\image\image-20221021112153975.png" alt="image-20221021112153975"></p>
<h3 id="分步骤看数据持久化过程"><a href="#分步骤看数据持久化过程" class="headerlink" title="分步骤看数据持久化过程"></a>分步骤看数据持久化过程</h3><blockquote>
<p><strong>通过分步骤看数据持久化过程</strong>：<strong>write -&gt; refresh -&gt; flush -&gt; merge</strong></p>
</blockquote>
<ul>
<li><strong>write 过程</strong></li>
</ul>
<p><img src="https://pdai.tech/_images/db/es/es-th-2-6.png" alt="img"></p>
<p>一个新文档过来，会存储在 in-memory buffer 内存缓存区中，顺便会记录 Translog（Elasticsearch 增加了一个 translog ，或者叫事务日志，在每一次对 Elasticsearch 进行操作时均进行了日志记录）。</p>
<p>这时候数据还没到 segment ，是搜不到这个新文档的。数据只有被 refresh 后，才可以被搜索到。</p>
<ul>
<li><strong>refresh 过程</strong></li>
</ul>
<p><img src="https://pdai.tech/_images/db/es/es-th-2-7.png" alt="img"></p>
<p>refresh 默认 1 秒钟，执行一次上图流程。ES 是支持修改这个值的，通过 index.refresh_interval 设置 refresh （冲刷）间隔时间。refresh 流程大致如下：</p>
<ol>
<li>in-memory buffer 中的文档写入到新的 segment 中，但 segment 是存储在文件系统的缓存中。此时文档可以被搜索到</li>
<li>最后清空 in-memory buffer。注意: Translog 没有被清空，为了将 segment 数据写到磁盘</li>
<li>文档经过 refresh 后， segment 暂时写到文件系统缓存，这样避免了性能 IO 操作，又可以使文档搜索到。refresh 默认 1 秒执行一次，性能损耗太大。一般建议稍微延长这个 refresh 时间间隔，比如 5 s。因此，ES 其实就是准实时，达不到真正的实时。</li>
</ol>
<ul>
<li><strong>flush 过程</strong>（将缓冲区的内容写出）</li>
</ul>
<p>每隔一段时间—例如 translog 变得越来越大—索引被刷新（flush）；一个新的 translog 被创建，并且一个全量提交被执行</p>
<p><img src="https://pdai.tech/_images/db/es/es-th-2-9.png" alt="img"></p>
<p>上个过程中 segment 在文件系统缓存中，会有意外故障文档丢失。那么，为了保证文档不会丢失，需要将文档写入磁盘。那么文档从文件缓存写入磁盘的过程就是 flush。写入磁盘后，清空 translog。具体过程如下：</p>
<ol>
<li>所有在内存缓冲区的文档都被写入一个新的段。</li>
<li>缓冲区被清空。</li>
<li>一个Commit Point被写入硬盘。</li>
<li>文件系统缓存通过 fsync 被刷新（flush）。</li>
<li>老的 translog 被删除。</li>
</ol>
<ul>
<li><p><strong>merge 过程</strong></p>
<p>为什么需要合并</p>
<p>flush（写出）每30分钟都会创建segment，segment会暴增。</p>
<p>每个请求都会查询所有的segment，搜索会慢</p>
<p>每个段都会消耗内存、cpu时间片去执行</p>
</li>
</ul>
<p>当索引的时候，刷新（refresh）操作会创建新的段并将段打开以供搜索使用。合并进程选择一小部分大小相似的段，并且在后台将它们合并到更大的段中。这并不会中断索引和搜索。</p>
<p><img src="https://pdai.tech/_images/db/es/es-th-2-10.png" alt="img"></p>
<p>一旦合并结束，老的段被删除：</p>
<ol>
<li>新的段被刷新（flush）到了磁盘。   ** 写入一个包含新段且排除旧的和较小的段的新提交点。</li>
<li>新的段被打开用来搜索。</li>
<li>老的段被删除。</li>
</ol>
<p><img src="https://pdai.tech/_images/db/es/es-th-2-11.png" alt="img"></p>
<h1 id="ES读取文档详解"><a href="#ES读取文档详解" class="headerlink" title="ES读取文档详解"></a>ES读取文档详解</h1><h2 id="单个文档-1"><a href="#单个文档-1" class="headerlink" title="单个文档"></a>单个文档</h2><p>以下是从主分片或者副本分片检索文档的步骤顺序：</p>
<p><img src="https://pdai.tech/_images/db/es/es-th-2-21.png" alt="img"></p>
<ol>
<li><p>客户端向 Master 发送获取请求。</p>
</li>
<li><p>节点路由规则计算请求分片，通过轮询所有分片负载均衡选择分片，然后查找到Node2下的R0分片 。</p>
</li>
<li><p>Node2节点将结果返回主节点，然后将文档返回给客户端。</p>
<p>存在没有将内存中的索引文档说refresh尽文件系统缓存中，也就是没写入到新的segment中，此时是不可搜索的状态。</p>
<p>此时查找副本分片会存在报告文档不存在，但是主分片可能成功返回文档。 一旦索引请求成功返回给用户，文档在主分片和副本分片都是可用的。</p>
</li>
</ol>
<h2 id="多个文档-1"><a href="#多个文档-1" class="headerlink" title="多个文档"></a>多个文档</h2><p>使用 mget 取回多个文档的步骤顺序：</p>
<p><img src="https://pdai.tech/_images/db/es/es-th-2-22.png" alt="img"></p>
<p>以下是使用单个 mget 请求取回多个文档所需的步骤顺序：</p>
<ol>
<li>客户端向Master发送 mget 请求。</li>
<li>Master为每个分片构建多文档获取请求，然后并行转发这些请求到托管在每个所需的主分片或者副本分片的节点上。一旦收到<strong>所有</strong>答复， master构建响应并将其返回给客户端。</li>
</ol>
<h2 id="文档读取过程详解"><a href="#文档读取过程详解" class="headerlink" title="文档读取过程详解"></a>文档读取过程详解</h2><ol>
<li>在初始查询阶段时，查询会广播到所有分片。 每个分片在本地执行搜索并构建一个匹配文档的大小为 from + size 的优先队列。PS：在2. 搜索的时候是会查询Filesystem Cache的，但是有部分数据还在Memory Buffer，所以搜索是近实时的。</li>
<li>每个分片返回各自优先队列中 所有文档的 ID 和排序值 给协调节点，它合并这些值到自己的优先队列中来产生一个全局排序后的结果列表。</li>
<li>接下来就是 取回阶段，协调节点辨别出哪些文档需要被取回并向相关的分片提交多个 GET 请求。每个分片加载并丰富文档，如果有需要的话，接着返回文档给协调节点。一旦所有的文档都被取回了，协调节点返回结果给客户端。</li>
</ol>
<h1 id="Es优化理论"><a href="#Es优化理论" class="headerlink" title="Es优化理论"></a>Es优化理论</h1><p>cpu、内存、硬盘-》提升IO，CPU</p>
<ul>
<li><p>CPU最好2核-8核</p>
</li>
<li><p>由于 ES 构建基于 lucene，而 lu lucene 能够很好的利用操作系统内存来缓存索引数据，以提供快速的查询性能。lucene 的索引文件 segements 是存储在单文件中的，并且不可变，对于 OS 来说，能够很友好地将索引文件保持在 cache 中，以便快速访问；因此，我们很有必要将一半的物理内存留给 lucene；另<strong>一半的物理内存留给 ES</strong>（JVM heap）。</p>
</li>
<li><p>禁止 swap，一旦允许内存与磁盘的交换，会引起致命的性能问题。可以通过在 elasticsearch.yml 中 bootstrap.memory_lock: true，以保持 JVM 锁定内存，保证 ES 的性能。</p>
</li>
<li><p>使用SSD或者<strong>RAID0</strong> 是由多个独立的高性能磁盘驱动器组成的磁盘子系统，带来倍数上的提升。</p>
</li>
</ul>
<h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><h3 id="批量提交"><a href="#批量提交" class="headerlink" title="批量提交"></a>批量提交</h3><p>当有大量数据提交的时候，建议采用批量提交（Bulk 操作）；此外使用 bulk 请求时，每个请求不超过几十M，因为太大会导致内存使用过大。</p>
<p>比如在做 ELK 过程中，Logstash indexer 提交数据到 Elasticsearch 中，batch size 就可以作为一个优化功能点。但是优化 size 大小需要根据文档大小和服务器性能而定。</p>
<p>像 Logstash 中提交文档大小超过 20MB，Logstash 会将一个批量请求切分为多个批量请求</p>
<p>如果在提交过程中，遇到 EsRejectedExecutionException 异常的话，则说明集群的索引性能已经达到极限了。这种情况，要么提高服务器集群的资源，要么根据业务规则，减少数据收集速度，比如只收集 Warn、Error 级别以上的日志。</p>
<h3 id="增加-Refresh-时间间隔"><a href="#增加-Refresh-时间间隔" class="headerlink" title="增加 Refresh 时间间隔"></a>增加 Refresh 时间间隔</h3><p>为了提高索引性能，Elasticsearch 在写入数据的时候，采用延迟写入的策略，即数据先写到内存中，当超过默认1秒（index.refresh_interval）会进行一次写入操作，就是将内存中 segment 数据刷新到磁盘中，此时我们才能将数据搜索出来，所以这就是为什么 Elasticsearch 提供的是近实时搜索功能，而不是实时搜索功能。</p>
<p>如果我们的系统对数据延迟要求不高的话，我们可以<strong>通过延长 refresh 时间间隔，可以有效地减少 segment 合并压力，提高索引速度</strong>。比如在做全链路跟踪的过程中，我们就将 index.refresh_interval 设置为30s，减少 refresh 次数。再如，在进行全量索引时，可以将 refresh 次数临时关闭，即 index.refresh_interval 设置为-1，数据导入成功后再打开到正常模式，比如30s。</p>
<blockquote>
<p>在加载大量数据时候可以暂时不用 refresh 和 repliccas，index.refresh_interval 设置为-1，index.number_of_replicas 设置为0。</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">JaHero</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/12/26/ES/ES%E5%9F%BA%E7%A1%80%E8%A1%A5%E5%81%BF/">http://example.com/2022/12/26/ES/ES%E5%9F%BA%E7%A1%80%E8%A1%A5%E5%81%BF/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">贾英雄-blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ES/">ES</a></div><div class="post_share"><div class="social-share" data-image="/img/post.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://fastly.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/12/26/ES/ES%E4%B8%ADIngest%E8%8A%82%E7%82%B9/" title="ES中Ingest节点"><img class="cover" src="/img/post.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-26</div><div class="title">ES中Ingest节点</div></div></a></div><div><a href="/2022/12/26/ES/ES%E4%B8%AD%E6%91%84%E5%8F%96%E7%AE%A1%E9%81%93%E8%AF%A6%E8%A7%A3/" title="ES中摄取管道详解"><img class="cover" src="/img/post.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-26</div><div class="title">ES中摄取管道详解</div></div></a></div><div><a href="/2022/12/26/ES/ES%E7%B4%A2%E5%BC%95%E9%87%8D%E5%BB%BAreindex%E8%AF%A6%E8%A7%A3/" title="ES索引重建reindex详解"><img class="cover" src="/img/post.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-26</div><div class="title">ES索引重建reindex详解</div></div></a></div><div><a href="/2022/12/26/ES/Elasticsearch%20%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%20Runtime%20fields%20%E6%B7%B1%E5%85%A5%E8%AF%A6%E8%A7%A3/" title="Elasticsearch 运行时类型 Runtime fields 深入详解"><img class="cover" src="/img/post.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-26</div><div class="title">Elasticsearch 运行时类型 Runtime fields 深入详解</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/ava.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">JaHero</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">495</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">294</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">118</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/JiaHero7/JiaHero7.github.io/" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#ES%E5%9F%BA%E7%A1%80%E8%A1%A5%E5%81%BF"><span class="toc-number">1.</span> <span class="toc-text">ES基础补偿</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E4%B8%8E%E8%81%9A%E5%90%88"><span class="toc-number">1.1.</span> <span class="toc-text">查询与聚合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.1.1.</span> <span class="toc-text">布尔查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.1.2.</span> <span class="toc-text">聚合查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E8%81%9A%E5%90%88"><span class="toc-number">1.1.3.</span> <span class="toc-text">嵌套聚合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%81%9A%E5%90%88%E7%BB%93%E6%9E%9C%E6%8E%92%E5%BA%8F"><span class="toc-number">1.1.4.</span> <span class="toc-text">对聚合结果排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">1.2.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.2.1.</span> <span class="toc-text">索引模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.2.</span> <span class="toc-text">模板类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%A8%A1%E6%9D%BF%E4%B8%AD%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.2.3.</span> <span class="toc-text">索引模板中的优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E7%B4%A2%E5%BC%95%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.2.4.</span> <span class="toc-text">内置索引模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">1.2.5.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DSL%E6%9F%A5%E8%AF%A2%E4%B9%8B%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.3.</span> <span class="toc-text">DSL查询之全文搜索详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-match%E6%90%9C%E7%B4%A2"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.match搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%8E%A7%E5%88%B6match%E7%9A%84%E5%8C%B9%E9%85%8D%E7%B2%BE%E5%BA%A6"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">2.控制match的匹配精度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%BF%91%E4%BC%BC%E5%8C%B9%E9%85%8D"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">3.近似匹配</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95-%E5%88%86%E8%AF%8D%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.3.2.</span> <span class="toc-text">扩展-分词位置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81match-phrase%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">4、match_phrase的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%BC%95%E5%85%A5slop"><span class="toc-number">1.3.2.1.1.</span> <span class="toc-text">1、引入slop</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%BC%95%E5%85%A5%E5%8F%AC%E5%9B%9E%E7%8E%87"><span class="toc-number">1.3.2.1.2.</span> <span class="toc-text">2、引入召回率</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E5%BC%95%E5%85%A5%E7%B2%BE%E5%87%86%E5%BA%A6"><span class="toc-number">1.3.2.1.3.</span> <span class="toc-text">3、引入精准度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#match%E5%92%8Cphrase-match-proximity-match-%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.2.1.4.</span> <span class="toc-text">match和phrase match(proximity match)区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-query-string%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.3.</span> <span class="toc-text">2.query string类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DSL%E6%9F%A5%E8%AF%A2%E4%B9%8BTerm%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.4.</span> <span class="toc-text">DSL查询之Term详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8-exist"><span class="toc-number">1.4.1.</span> <span class="toc-text">字段是否存在:exist</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#id%E6%9F%A5%E8%AF%A2-ids"><span class="toc-number">1.4.2.</span> <span class="toc-text">id查询:ids</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BC%80-prefix"><span class="toc-number">1.4.3.</span> <span class="toc-text">前缀:prefix</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E8%AF%8D%E5%8C%B9%E9%85%8D-term"><span class="toc-number">1.4.4.</span> <span class="toc-text">分词匹配:term</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E5%88%86%E8%AF%8D%E5%8C%B9%E9%85%8D-terms"><span class="toc-number">1.4.5.</span> <span class="toc-text">多个分词匹配:terms</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E6%9F%90%E4%B8%AA%E6%95%B0%E5%AD%97%E5%AD%97%E6%AE%B5%E5%88%86%E8%AF%8D%E5%8C%B9%E9%85%8D-term-set"><span class="toc-number">1.4.6.</span> <span class="toc-text">按某个数字字段分词匹配:term set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8C%83%E5%9B%B4-range"><span class="toc-number">1.4.7.</span> <span class="toc-text">范围:range</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E7%B3%8A%E5%8C%B9%E9%85%8D-fuzzy"><span class="toc-number">1.4.8.</span> <span class="toc-text">模糊匹配:fuzzy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E9%85%8D%E7%AC%A6-wildcard"><span class="toc-number">1.4.9.</span> <span class="toc-text">通配符:wildcard</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E7%9A%84%E5%BC%95%E5%85%A5"><span class="toc-number">1.5.</span> <span class="toc-text">聚合的引入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3Bucket%E8%81%9A%E5%90%88"><span class="toc-number">1.5.1.</span> <span class="toc-text">如何理解Bucket聚合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%84%9A%E6%9C%AC%E7%9A%84%E8%81%9A%E5%90%88"><span class="toc-number">1.5.2.</span> <span class="toc-text">动态脚本的聚合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E6%A1%B6%E5%88%86%E7%B1%BB%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.5.3.</span> <span class="toc-text">按桶分类学习</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E6%9D%A1%E4%BB%B6%E7%9A%84%E8%BF%87%E6%BB%A4%EF%BC%9Afilter"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">前置条件的过滤：filter</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8filter-%E5%9F%BA%E7%A1%80%E4%B8%8A%E5%8A%A0-post-filter-%E5%9C%BA%E6%99%AF"><span class="toc-number">1.5.3.1.1.</span> <span class="toc-text">在filter 基础上加 post_filter 场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9Filter%E8%BF%9B%E8%A1%8C%E5%88%86%E7%BB%84%E8%81%9A%E5%90%88%EF%BC%8C%E5%88%86%E6%88%90%E4%B8%89%E4%B8%AA%E7%BB%84%EF%BC%8C%E6%8E%92%E9%99%A4%E5%9C%A8Info%E5%92%8Cwarn%E5%88%86%E7%BB%84%E5%A4%96%E7%9A%84other%E7%BB%84%E3%80%82"><span class="toc-number">1.5.3.1.2.</span> <span class="toc-text">对Filter进行分组聚合，分成三个组，排除在Info和warn分组外的other组。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9number%E7%B1%BB%E5%9E%8B%E8%81%9A%E5%90%88%EF%BC%9ARange"><span class="toc-number">1.5.3.1.3.</span> <span class="toc-text">对number类型聚合：Range</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9IP%E7%B1%BB%E5%9E%8B%E8%81%9A%E5%90%88%EF%BC%9AIP-Range"><span class="toc-number">1.5.3.1.4.</span> <span class="toc-text">对IP类型聚合：IP Range</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E6%97%A5%E6%9C%9F%E7%B1%BB%E5%9E%8B%E8%81%9A%E5%90%88%EF%BC%9ADate-Range"><span class="toc-number">1.5.3.1.5.</span> <span class="toc-text">对日期类型聚合：Date Range</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E6%9F%B1%E7%8A%B6%E5%9B%BE%E5%8A%9F%E8%83%BD%EF%BC%9AHistrogram%EF%BC%88%E7%89%B9%E6%AE%8A%E5%8A%9F%E8%83%BD%EF%BC%89"><span class="toc-number">1.5.3.1.6.</span> <span class="toc-text">对柱状图功能：Histrogram（特殊功能）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%A6%E9%87%8F%E8%81%9A%E5%90%88"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">度量聚合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E8%81%9A%E5%90%88"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">管道聚合</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES%E5%8E%9F%E7%90%86%E5%88%9D%E6%AD%A5%E8%AE%A4%E7%9F%A5"><span class="toc-number">1.6.</span> <span class="toc-text">ES原理初步认知</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86Lucene"><span class="toc-number">1.6.1.</span> <span class="toc-text">认识Lucene</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">1.7.</span> <span class="toc-text">ES核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4"><span class="toc-number">1.7.1.</span> <span class="toc-text">集群</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">发现机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%84%E6%92%AD"><span class="toc-number">1.7.1.2.1.</span> <span class="toc-text">组播</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E6%92%AD"><span class="toc-number">1.7.1.2.2.</span> <span class="toc-text">单播</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE"><span class="toc-number">1.7.1.2.3.</span> <span class="toc-text">配置</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#master%E9%80%89%E4%B8%BE%E8%B0%81%E5%8F%91%E8%B5%B7%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%91%E8%B5%B7%EF%BC%9F"><span class="toc-number">1.7.1.3.</span> <span class="toc-text">master选举谁发起，什么时候发起？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ES%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E4%BB%A5%E5%8F%8A%E9%80%89%E4%B8%BEMaster%E6%B5%81%E7%A8%8B%EF%BC%88zen-discovery%EF%BC%89"><span class="toc-number">1.7.1.4.</span> <span class="toc-text">ES服务发现以及选举Master流程（zen discovery）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E7%9A%84%E8%A7%92%E8%89%B2"><span class="toc-number">1.7.2.</span> <span class="toc-text">节点的角色</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%8A%82%E7%82%B9"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">数据节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%99%E9%80%89%E4%B8%BB%E8%8A%82%E7%82%B9"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">候选主节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E8%8A%82%E7%82%B9"><span class="toc-number">1.7.2.3.</span> <span class="toc-text">主节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E8%B0%83%E8%8A%82%E7%82%B9"><span class="toc-number">1.7.2.4.</span> <span class="toc-text">协调节点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%84%91%E8%A3%82"><span class="toc-number">1.7.3.</span> <span class="toc-text">脑裂</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">产生原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%8E%AA%E6%96%BD"><span class="toc-number">1.7.3.2.</span> <span class="toc-text">优化措施</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%89%87"><span class="toc-number">1.8.</span> <span class="toc-text">分片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%EF%BC%88Mapping%EF%BC%89"><span class="toc-number">1.9.</span> <span class="toc-text">映射（Mapping）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ES%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86"><span class="toc-number">2.</span> <span class="toc-text">ES初步认识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Lucene%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.</span> <span class="toc-text">Lucene原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Inverted-Index"><span class="toc-number">2.1.1.</span> <span class="toc-text">Inverted Index</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stored-Field%E5%AD%97%E6%AE%B5%E6%9F%A5%E6%89%BE"><span class="toc-number">2.1.2.</span> <span class="toc-text">Stored Field字段查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Document-Values%E4%B8%BA%E4%BA%86%E6%8E%92%E5%BA%8F%EF%BC%8C%E8%81%9A%E5%90%88"><span class="toc-number">2.1.3.</span> <span class="toc-text">Document Values为了排序，聚合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E5%8F%91%E7%94%9F%E6%97%B6"><span class="toc-number">2.1.4.</span> <span class="toc-text">搜索发生时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%9A%84%E6%95%85%E4%BA%8B"><span class="toc-number">2.1.5.</span> <span class="toc-text">缓存的故事</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8Shard%E4%B8%AD%E6%90%9C%E7%B4%A2"><span class="toc-number">2.1.6.</span> <span class="toc-text">在Shard中搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">2.1.7.</span> <span class="toc-text">请求的过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Es%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">Es整体结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%85-Lucene%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">补充:Lucene索引结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%85-Lucene%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-number">3.2.</span> <span class="toc-text">补充:Lucene处理流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ES%E7%B4%A2%E5%BC%95%E6%96%87%E6%A1%A3%E8%AF%A6%E8%A7%A3"><span class="toc-number">4.</span> <span class="toc-text">ES索引文档详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%B8%AA%E6%96%87%E6%A1%A3"><span class="toc-number">4.0.1.</span> <span class="toc-text">单个文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E6%96%87%E6%A1%A3"><span class="toc-number">4.0.2.</span> <span class="toc-text">多个文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E7%9A%84%E7%B4%A2%E5%BC%95%E6%B5%81%E7%A8%8B"><span class="toc-number">4.0.3.</span> <span class="toc-text">整体的索引流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%AD%A5%E9%AA%A4%E7%9C%8B%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="toc-number">4.0.4.</span> <span class="toc-text">分步骤看数据持久化过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ES%E8%AF%BB%E5%8F%96%E6%96%87%E6%A1%A3%E8%AF%A6%E8%A7%A3"><span class="toc-number">5.</span> <span class="toc-text">ES读取文档详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%B8%AA%E6%96%87%E6%A1%A3-1"><span class="toc-number">5.1.</span> <span class="toc-text">单个文档</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E6%96%87%E6%A1%A3-1"><span class="toc-number">5.2.</span> <span class="toc-text">多个文档</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E6%A1%A3%E8%AF%BB%E5%8F%96%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3"><span class="toc-number">5.3.</span> <span class="toc-text">文档读取过程详解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Es%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA"><span class="toc-number">6.</span> <span class="toc-text">Es优化理论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96"><span class="toc-number">6.1.</span> <span class="toc-text">索引优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E6%8F%90%E4%BA%A4"><span class="toc-number">6.1.1.</span> <span class="toc-text">批量提交</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0-Refresh-%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94"><span class="toc-number">6.1.2.</span> <span class="toc-text">增加 Refresh 时间间隔</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/12/31/image/%E7%AC%AC%E4%B8%80%E5%A4%A9%E7%AC%94%E8%AE%B0/" title="无题"><img src="/img/post.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2022/12/31/image/%E7%AC%AC%E4%B8%80%E5%A4%A9%E7%AC%94%E8%AE%B0/" title="无题">无题</a><time datetime="2022-12-31T04:24:34.153Z" title="发表于 2022-12-31 12:24:34">2022-12-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/31/img/index/" title="gallery"><img src="/img/post.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="gallery"/></a><div class="content"><a class="title" href="/2022/12/31/img/index/" title="gallery">gallery</a><time datetime="2022-12-30T18:20:45.000Z" title="发表于 2022-12-31 02:20:45">2022-12-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/30/hello-world/" title="Hello World"><img src="/img/post.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/2022/12/30/hello-world/" title="Hello World">Hello World</a><time datetime="2022-12-30T09:13:14.141Z" title="发表于 2022-12-30 17:13:14">2022-12-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/26/Aop%E6%B3%A8%E8%A7%A3/" title="Aop注解"><img src="/img/post.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Aop注解"/></a><div class="content"><a class="title" href="/2022/12/26/Aop%E6%B3%A8%E8%A7%A3/" title="Aop注解">Aop注解</a><time datetime="2022-12-26T04:40:09.000Z" title="发表于 2022-12-26 12:40:09">2022-12-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/26/Flowable%20%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%BC%95%E6%93%8E/" title="Flowable 工作流程引擎"><img src="/img/post.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Flowable 工作流程引擎"/></a><div class="content"><a class="title" href="/2022/12/26/Flowable%20%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%BC%95%E6%93%8E/" title="Flowable 工作流程引擎">Flowable 工作流程引擎</a><time datetime="2022-12-26T04:40:09.000Z" title="发表于 2022-12-26 12:40:09">2022-12-26</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/post.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 By JaHero</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/algolia.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script src="https://fastly.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>