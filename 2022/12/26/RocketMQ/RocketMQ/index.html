<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>RocketMQ | 贾英雄-blog</title><meta name="keywords" content="RocketMQ"><meta name="author" content="JaHero"><meta name="copyright" content="JaHero"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="RocketMQ原文地址 消息队列的三大用途：异步-削峰-解耦 RocketMQ优缺点基于Java开发 可用性：高 可靠性：经过参数优化配置，消息可以做到0丢失 可扩展性：功能完善，分布式扩展性好 缺点 支持的客户端语言不多，只有java和c++ 没有在MQ核心去实现JMS等接口，系统迁移很费劲 消息队列模型队列模型以及订阅发布模型 队列模型 消费者之间是竞争关系，一条消息只能被消费一次  发布订">
<meta property="og:type" content="article">
<meta property="og:title" content="RocketMQ">
<meta property="og:url" content="http://example.com/2022/12/26/RocketMQ/RocketMQ/index.html">
<meta property="og:site_name" content="贾英雄-blog">
<meta property="og:description" content="RocketMQ原文地址 消息队列的三大用途：异步-削峰-解耦 RocketMQ优缺点基于Java开发 可用性：高 可靠性：经过参数优化配置，消息可以做到0丢失 可扩展性：功能完善，分布式扩展性好 缺点 支持的客户端语言不多，只有java和c++ 没有在MQ核心去实现JMS等接口，系统迁移很费劲 消息队列模型队列模型以及订阅发布模型 队列模型 消费者之间是竞争关系，一条消息只能被消费一次  发布订">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/post.jpg">
<meta property="article:published_time" content="2022-12-26T04:40:09.000Z">
<meta property="article:modified_time" content="2022-12-26T05:25:04.636Z">
<meta property="article:author" content="JaHero">
<meta property="article:tag" content="RocketMQ">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/post.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/12/26/RocketMQ/RocketMQ/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css" media="print" onload="this.media='all'"><script src="https://fastly.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"K46KXS6BKG","apiKey":"94dab3de87ce4cc2067ec6ef569e9df7","indexName":"JiaHero","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: JaHero","link":"链接: ","source":"来源: 贾英雄-blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://fastly.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://fastly.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://fastly.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://fastly.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://fastly.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'RocketMQ',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2022-12-26 13:25:04'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    document.addEventListener('pjax:complete', detectApple)})(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/ava.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">495</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">294</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">118</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/photos/"><i class="fa-fw image"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/post.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">贾英雄-blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/photos/"><i class="fa-fw image"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">RocketMQ</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-26T04:40:09.000Z" title="发表于 2022-12-26 12:40:09">2022-12-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-26T05:25:04.636Z" title="更新于 2022-12-26 13:25:04">2022-12-26</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">17.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>55分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="RocketMQ"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h1><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/2TeUYAodDKG0gvuuVzAdPw">原文地址</a></p>
<p>消息队列的三大用途：异步-削峰-解耦</p>
<h2 id="RocketMQ优缺点"><a href="#RocketMQ优缺点" class="headerlink" title="RocketMQ优缺点"></a>RocketMQ优缺点</h2><p>基于Java开发</p>
<p>可用性：高</p>
<p>可靠性：经过参数优化配置，消息可以做到0丢失</p>
<p>可扩展性：功能完善，分布式扩展性好</p>
<p>缺点</p>
<p>支持的客户端语言不多，只有java和c++</p>
<p>没有在MQ核心去实现JMS等接口，系统迁移很费劲</p>
<h2 id="消息队列模型"><a href="#消息队列模型" class="headerlink" title="消息队列模型"></a>消息队列模型</h2><p>队列模型以及订阅发布模型</p>
<p>队列模型</p>
<p>消费者之间是竞争关系，一条消息只能被消费一次</p>
<p><img src="F:\hexo-blog-lionkk-master\hexo-blog-lionkk-master\source_posts\image\queue.png"></p>
<p>发布订阅模型</p>
<p><img src="F:\hexo-blog-lionkk-master\hexo-blog-lionkk-master\source_posts\image\微信图片_20221102091715.png"></p>
<p>两种模型的异同：都有生产者、队列、消费者，区别在于一条消息是否可以被多个消费者消费</p>
<h2 id="RocketMQ模型"><a href="#RocketMQ模型" class="headerlink" title="RocketMQ模型"></a>RocketMQ模型</h2><p>RocketMQ采用的是发布订阅模型</p>
<p><img src="F:\hexo-blog-lionkk-master\hexo-blog-lionkk-master\source_posts\image\微信图片_20221102092322.png"></p>
<p><strong>Message</strong></p>
<p>必须有Topic，可选Tag和额外的键值对（用于设置一个业务 Key 并在 Broker 上查找此消息以便在开发期间查找问题）</p>
<p><strong>Topic</strong> </p>
<p>消息的大类指的是控制器级别如交易消息，消息的小类由Tag区分指的是接口级别，例如交易完成消息、交易创建消息。</p>
<p><strong>Group</strong></p>
<p>体现在消费者组上，每个消费者组都会得到一份完整的消息（主题Topic或者Tag），订阅了</p>
<p>RocketMQ中，订阅者的概念是通过消费组（Consumer Group）来体现的。每个消费组都消费主题中一份完整的消息，不同消费组之间消费进度彼此不受影响，也就是说，一条消息被Consumer Group1消费过，也会再给Consumer Group2消费。</p>
<p>消费组中包含多个消费者，同一个组内的消费者是竞争消费的关系，每个消费者负责消费组内的一部分消息。默认情况，如果一条消息被消费者Consumer1消费了，那同组的其他消费者就不会再收到这条消息。</p>
<ul>
<li><strong>Message Queue</strong></li>
</ul>
<p><strong>Message Queue</strong>（消息队列），一个 Topic 下可以设置多个消息队列，Topic 包括多个 Message Queue ，如果一个 Consumer 需要获取 Topic下所有的消息，就要遍历所有的 Message Queue。</p>
<p>RocketMQ还有一些其它的Queue——例如ConsumerQueue。</p>
<ul>
<li><strong>Offset</strong></li>
</ul>
<p>在Topic的消费过程中，由于消息需要被不同的组进行多次消费，所以消费完的消息并不会立即被删除，这就需要RocketMQ为每个消费组在每个队列上维护一个消费位置（Consumer Offset），这个位置之前的消息都被消费过，之后的消息都没有被消费过，每成功消费一条消息，消费位置就加一。</p>
<p>也可以这么说，<code>Queue</code> 是一个长度无限的数组，<strong>Offset</strong> 就是下标。</p>
<p>RocketMQ的消息模型中，这些就是比较关键的概念了。画张图总结一下：</p>
<p><img src="F:\hexo-blog-lionkk-master\hexo-blog-lionkk-master\source_posts\image\微信图片_20221102093545.png"></p>
<h2 id="消费模式"><a href="#消费模式" class="headerlink" title="消费模式"></a>消费模式</h2><p>集群消费和广播消费</p>
<p>默认为集群消费，一个消费者组共同消费一个主题，一个队列只能被一个消费者消费（不能反过来，因为一个队列的消费者挂掉就由其他消费者继续消费）</p>
<p>而广播消费为每个消费者都能对同一消息进行消费。</p>
<h2 id="RocketMQ基本架构"><a href="#RocketMQ基本架构" class="headerlink" title="RocketMQ基本架构"></a>RocketMQ基本架构</h2><p>Producer（生产者）、consumer（消费者）、Broker集群</p>
<p>、Name Server集群，它们分别对应发、收、存、<strong>发现</strong>。</p>
<p><img src="F:\hexo-blog-lionkk-master\hexo-blog-lionkk-master\source_posts\image\微信图片_20221107150054.png"></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/xVMdyHyQ8uf_uGjwF8-u9w">文章地址</a></p>
<h2 id="RocketMQ框架核心概念"><a href="#RocketMQ框架核心概念" class="headerlink" title="RocketMQ框架核心概念"></a>RocketMQ框架核心概念</h2><h3 id="NameServer"><a href="#NameServer" class="headerlink" title="NameServer"></a><strong>NameServer</strong></h3><p>是一个无状态的服务器，角色类似于 Kafka使用的 Zookeeper，但比 Zookeeper 更轻量。<br>特点：</p>
<ul>
<li>每个 NameServer 结点之间是相互独立，彼此没有任何信息交互。</li>
<li>Nameserver 被设计成几乎是无状态的，通过部署多个结点来标识自己是一个伪集群，Producer 在发送消息前从 NameServer 中获取 Topic 的路由信息也就是发往哪个 Broker，Consumer 也会定时从 NameServer 获取 Topic 的路由信息，Broker 在启动时会向 NameServer 注册，并定时进行心跳连接，且定时同步维护的 Topic 到 NameServer。</li>
<li>Broker会注册到<strong>所有的NameServer</strong>中，防止单台NameServer挂掉导致Broker信息不全，保证NameServer的集群高可用</li>
</ul>
<p>功能主要有两个：</p>
<p>1、和Broker 结点保持长连接。</p>
<p>2、维护 Topic 的路由信息</p>
<h3 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h3><p>消息存储和中转角色，负责存储和转发消息。</p>
<ul>
<li>Broker 内部维护着一个个 Consumer Queue，用来存储消息的索引，真正存储消息的地方是 CommitLog（日志文件）。</li>
</ul>
<p><img src="F:\hexo-blog-lionkk-master\hexo-blog-lionkk-master\source_posts\image\640.png"></p>
<p>RocketMQ存储-图片来源官网</p>
<ul>
<li>单个 Broker 与注册到所有的 Nameserver并 保持着长连接和心跳，并会定时将 Topic 信息同步到 NameServer，和 NameServer 的通信底层是通过 Netty 实现的。</li>
<li>在一个Broker集群中，相同的BrokerName称为Broker组。在Broker组中,BrokerId为0的为主节点，其它的为从节点。BrokerName和BrokerId是可以在Broker启动时通过配置文件配置的。每个Broker组只存放一部分消息。</li>
</ul>
<h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><p>消息生产者，业务端负责发送消息，由用户自行实现和分布式部署。</p>
<ul>
<li><p><strong>Producer</strong>由用户进行分布式部署，消息由<strong>Producer</strong>通过多种负载均衡模式发送到<strong>Broker</strong>集群，发送低延时，支持快速失败。</p>
</li>
<li><p><strong>RocketMQ</strong> 提供了三种方式发送消息：同步、异步和单向</p>
</li>
<li><ul>
<li><strong>同步发送</strong>：同步发送指消息发送方发出数据后会在收到接收方发回响应之后才发下一个数据包。一般用于重要通知消息，例如重要通知邮件、营销短信。</li>
<li><strong>异步发送</strong>：异步发送指发送方发出数据后，不等接收方发回响应，接着发送下个数据包，一般用于可能链路耗时较长而对响应时间敏感的业务场景，例如用户视频上传后通知启动转码服务。</li>
<li><strong>单向发送</strong>：单向发送是指只负责发送消息而不等待服务器回应且没有回调函数触发，适用于某些耗时非常短但对可靠性要求并不高的场景，例如日志收集。</li>
</ul>
</li>
</ul>
<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>负责消费消息，一般异步消费。</p>
<ul>
<li><strong>Consumer</strong>也由用户部署，支持PUSH（被动）和PULL（主动）两种消费模式，支持<strong>集群消费</strong>和<strong>广播消费</strong>，提供<strong>实时的消息订阅机制</strong>。</li>
<li><strong>Pull</strong>：拉取型消费者（Pull Consumer）主动从消息服务器拉取信息，只要批量拉取到消息，用户应用就会启动消费过程，所以 Pull 称为主动消费型。</li>
<li><strong>Push</strong>：推送型消费者（Push Consumer）封装了消息的拉取、消费进度和其他的内部维护工作，将消息到达时执行的回调接口留给用户应用程序来实现。所以 Push  称为被动消费类型，但其实从实现上看还是从消息服务器中拉取消息，不同于 Pull 的是 <strong>Push  首先要注册消费监听器</strong>，当监听器处触发后才开始消费消息。</li>
</ul>
<p><strong>topic（主题）</strong>：可以理解为一个消息的集合的名字，生产者在发送消息的时候需要指定发到哪个topic下，消费者消费消息的时候也需要知道自己消费的是哪些topic底下的消息。</p>
<p><strong>Tag（子主题）</strong>：比topic低一级，可以用来区分同一topic下的不同业务类型的消息，发送消息的时候也需要指定。</p>
<h2 id="RocketMQ保证消息的高可用"><a href="#RocketMQ保证消息的高可用" class="headerlink" title="RocketMQ保证消息的高可用"></a>RocketMQ保证消息的高可用</h2><p><img src="F:\hexo-blog-lionkk-master\hexo-blog-lionkk-master\source_posts\image\微信图片_20221107151826.png"></p>
<h3 id="生产阶段"><a href="#生产阶段" class="headerlink" title="生产阶段"></a>生产阶段</h3><p><strong>通过请求确认机制，来保证消息的可靠传递</strong>。</p>
<p>对应着生产者三种生产方式，同步、异步、</p>
<ul>
<li>1、同步模式：要注意处理响应结果和异常。如果返回响应OK，表示消息成功发送到了Broker，如果响应失败，或者发生其它异常，都应该重试。</li>
<li>2、异步模式：应该在回调方法里检查，如果发送失败或者异常，都应该进行重试。</li>
<li>3、单向模式：如果发生超时的情况，也可以通过查询日志的API，来检查是否在Broker存储成功。</li>
</ul>
<h3 id="存储阶段"><a href="#存储阶段" class="headerlink" title="存储阶段"></a>存储阶段</h3><p>通过<strong>配置可靠性优先的 Broker 参数来避免因为宕机丢消息</strong></p>
<p>通过Broker的同异步刷盘机制以及broker的主从同异步复制机制保证消息高可用，简单说就是可靠性优先的场景都应该使用同步。</p>
<ul>
<li>1、消息只要持久化到CommitLog（日志文件）中，即使Broker宕机，未消费的消息也能重新恢复再消费。</li>
<li>2、Broker的刷盘机制：同步刷盘和异步刷盘，不管哪种刷盘都可以保证消息一定存储在pagecache中（内存中），但是同步刷盘更可靠，它是Producer发送消息后等数据持久化到磁盘之后再返回响应给Producer。</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdpDiaP0AiaXoF5EGDSJ5zPgFsPLrtEyIZkZRR6Hd0TUVatyW314mCNqJxOvnBn3rbMNJiaPKBxllk6Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">同步刷盘和异步刷盘-图片来源官网</p>
<ul>
<li>3、Broker通过主从模式来保证高可用，Broker支持Master和Slave同步复制、Master和Slave异步复制模式，生产者的消息都是发送给Master，但是消费既可以从Master消费，也可以从Slave消费。同步复制模式可以保证即使Master宕机，消息肯定在Slave中有备份，保证了消息不会丢失。</li>
</ul>
<h3 id="消费阶段"><a href="#消费阶段" class="headerlink" title="消费阶段"></a>消费阶段</h3><p>Consumer在执行完所有消费业务逻辑之后，再发送消费确认。因为消息队列维护了消费的位置，逻辑执行失败了，没有确认，再去队列拉取消息，就还是之前的一条。</p>
<h2 id="RocketMQ的高可用"><a href="#RocketMQ的高可用" class="headerlink" title="RocketMQ的高可用"></a>RocketMQ的高可用</h2><p>NameServer因为是无状态，且不相互通信的，所以只要集群部署就可以保证高可用。</p>
<p><img src="F:\hexo-blog-lionkk-master\hexo-blog-lionkk-master\source_posts\image\650" alt="图片"></p>
<p>RocketMQ的高可用主要是在体现在Broker的读和写的高可用，Broker的高可用是通过<code>集群</code>和<code>主从</code>实现的。</p>
<p><img src="F:\hexo-blog-lionkk-master\hexo-blog-lionkk-master\source_posts\image\651" alt="图片"></p>
<p>Broker可以配置两种角色：Master和Slave，Master角色的Broker支持读和写，Slave角色的Broker只支持读，Master会向Slave同步消息。</p>
<p>Consumer 的配置文件中，并不需要设置是从 Master 读还是从 Slave读，当 Master 不可用或者繁忙的时候， Consumer 的读请求会被自动切换到从 Slave。有了自动切换 Consumer 这种机制，当一个 Master 角色的机器出现故障后，Consumer 仍然可以从 Slave 读取消息，不影响 Consumer 读取消息，这就实现了读的高可用。</p>
<p>如何达到发送端写的高可用性呢？在创建 Topic 的时候，把 Topic 的多个Message Queue 创建在多个 Broker 组上（相同 Broker 名称，不同 brokerId机器组成 Broker 组），这样当 Broker 组的 Master 不可用后，其他组Master 仍然可用， Producer 仍然可以发送消息 RocketMQ 目前还<strong>不支持把Slave自动转成 Master</strong> ，如果机器资源不足，需要把 Slave 转成 Master ，则要手动停止 Slave 的 Broker ，更改配置文件，用新的配置文件启动 Broker。</p>
<h2 id="RocketMQ处理消息不重复"><a href="#RocketMQ处理消息不重复" class="headerlink" title="RocketMQ处理消息不重复"></a>RocketMQ处理消息不重复</h2><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><p>对分布式消息队列来说，同时做到确保一定投递和不重复投递是很难的，就是所谓的“有且仅有一次” 。RocketMQ择了确保一定投递，保证消息不丢失，但有可能造成消息重复。</p>
<p>主要有业务端自己保证，主要的方式有两种：<strong>业务幂等</strong>和<strong>消息去重</strong>。</p>
<p><img src="F:\hexo-blog-lionkk-master\hexo-blog-lionkk-master\source_posts\image\641" alt="图片"></p>
<h3 id="业务幂等"><a href="#业务幂等" class="headerlink" title="业务幂等"></a>业务幂等</h3><p>第一种生产端保证消费逻辑的幂等性，也就是多次调用和一次调用的效果是一样的。</p>
<h3 id="消息去重"><a href="#消息去重" class="headerlink" title="消息去重"></a>消息去重</h3><p>第二种是业务端，对重复的消息就不再消费了。这种方法，需要保证每条消息都有一个惟一的编号，通常是业务相关的，比如订单号，消费的记录需要落库，而且需要保证和消息确认这一步的原子性。</p>
<p>具体做法是可以建立一个消费记录表，拿到这个消息做数据库的insert操作。给这个消息做一个唯一主键（primary key）或者唯一约束，那么就算出现重复消费的情况，就会导致主键冲突，那么就不再处理这条消息。</p>
<h2 id="RocketMQ处理消息积压"><a href="#RocketMQ处理消息积压" class="headerlink" title="RocketMQ处理消息积压"></a>RocketMQ处理消息积压</h2><p><img src="F:\hexo-blog-lionkk-master\hexo-blog-lionkk-master\source_posts\image\微信图片_20221107153611.png"></p>
<h3 id="消费者扩容（消费者不足）"><a href="#消费者扩容（消费者不足）" class="headerlink" title="消费者扩容（消费者不足）"></a>消费者扩容（消费者不足）</h3><p>如果当前Topic的Message Queue的数量大于消费者数量，就可以对消费者进行扩容，增加消费者，来提高消费能力。</p>
<h3 id="消息迁移Queue扩容"><a href="#消息迁移Queue扩容" class="headerlink" title="消息迁移Queue扩容"></a>消息迁移Queue扩容</h3><p>第一步通过消费者将堆积的消息转发到创建临时的Topic存储多个消息队列</p>
<p>第二步对消费者临时扩容，将临时的消费者去消费这部分消息，消费完恢复原状。</p>
<p><img src="F:\hexo-blog-lionkk-master\hexo-blog-lionkk-master\source_posts\image\微信图片_20221107154607.png"></p>
<h2 id="RocketMQ实现顺序消息"><a href="#RocketMQ实现顺序消息" class="headerlink" title="RocketMQ实现顺序消息"></a>RocketMQ实现顺序消息</h2><p>顺序消息是指消息的消费顺序和产生顺序相同，在有些业务逻辑下，必须保证顺序，比如订单的生成、付款、发货，这个消息必须按顺序处理才行。</p>
<p><img src="F:\hexo-blog-lionkk-master\hexo-blog-lionkk-master\source_posts\image\642" alt="图片"></p>
<p>顺序消息分为全局顺序消息和部分顺序消息，全局顺序消息指某个 Topic 下的所有消息都要保证顺序；</p>
<p>部分顺序消息只要保证每一组消息被顺序消费即可，比如订单消息，只要保证同一个订单 ID 个消息能按顺序消费即可。</p>
<h4 id="部分顺序消息"><a href="#部分顺序消息" class="headerlink" title="部分顺序消息"></a>部分顺序消息</h4><p>部分顺序消息相对比较好实现，生产端需要做到把同 ID 的消息发送到同一个 Message Queue ；在消费过程中，要做到从同一个Message Queue读取的消息顺序处理——消费端不能并发处理顺序消息，这样才能达到部分有序。</p>
<p><img src="F:\hexo-blog-lionkk-master\hexo-blog-lionkk-master\source_posts\image\643" alt="图片">部分顺序消息</p>
<p>发送端使用 MessageQueueSelector 类来控制 把消息发往哪个 Message Queue 。</p>
<p><img src="F:\hexo-blog-lionkk-master\hexo-blog-lionkk-master\source_posts\image\644" alt="图片">顺序消息生产-例子来源官方</p>
<p>消费端通过使用 MessageListenerOrderly 来解决单 Message Queue 的消息被并发处理的问题。<img src="https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdpDiaP0AiaXoF5EGDSJ5zPgFniaWqQyFzKIW3FybFWaSeHkbtz9kHJH9Zu4vElH9Azw8X0z7F2l9Gmw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h4 id="全局顺序消息"><a href="#全局顺序消息" class="headerlink" title="全局顺序消息"></a>全局顺序消息</h4><p>RocketMQ 默认情况下不保证顺序，比如创建一个 Topic ，默认八个写队列，八个读队列，这时候一条消息可能被写入任意一个队列里；在数据的读取过程中，可能有多个 Consumer ，每个 Consumer 也可能启动多个线程并行处理，所以消息被哪个 Consumer 消费，被消费的顺序和写人的顺序是否一致是不确定的。</p>
<p>要保证全局顺序消息， 需要先<strong>把 Topic 的读写队列数设置为 一，然后Producer Consumer 的并发设置也要是一</strong>。简单来说，为了保证整个 Topic全局消息有序，只能消除所有的并发处理，各部分都设置成单线程处理 ，这时候就完全牺牲RocketMQ的高并发、高吞吐的特性了。</p>
<p><img src="F:\hexo-blog-lionkk-master\hexo-blog-lionkk-master\source_posts\image\645" alt="图片"></p>
<h2 id="RocketMQ实现消息过滤"><a href="#RocketMQ实现消息过滤" class="headerlink" title="RocketMQ实现消息过滤"></a>RocketMQ实现消息过滤</h2><p>有两种方案：</p>
<ul>
<li>一种是在 Broker 端按照 Consumer 的去重逻辑进行过滤，这样做的好处是避免了无用的消息传输到 Consumer 端，缺点是加重了 Broker 的负担，实现起来相对复杂。</li>
<li>另一种是在 Consumer 端过滤，比如按照消息设置的 tag 去重，这样的好处是实现起来简单，缺点是有大量无用的消息到达了 Consumer 端只能丢弃不处理。</li>
</ul>
<p>一般采用Cosumer端过滤，如果希望提高吞吐量，可以采用Broker过滤。</p>
<p>对消息的过滤有三种方式：</p>
<p><img src="F:\hexo-blog-lionkk-master\hexo-blog-lionkk-master\source_posts\image\646" alt="图片"></p>
<p>根据Tag过滤：这是最常见的一种，用起来高效简单</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(&quot;CID_EXAMPLE&quot;);</span><br><span class="line">consumer.subscribe(&quot;TOPIC&quot;, &quot;TAGA || TAGB || TAGC&quot;);</span><br></pre></td></tr></table></figure>

<p>SQL 表达式过滤：SQL表达式过滤更加灵活</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;please_rename_unique_group_name_4&quot;</span>);</span><br><span class="line"><span class="comment">// 只有订阅的消息有这个属性a, a &gt;=0 and a &lt;= 3</span></span><br><span class="line">consumer.subscribe(<span class="string">&quot;TopicTest&quot;</span>, MessageSelector.bySql(<span class="string">&quot;a between 0 and 3&quot;</span>);</span><br><span class="line">consumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line">consumer.start();</span><br></pre></td></tr></table></figure>

<p>Filter Server 方式：最灵活，也是最复杂的一种方式，允许用户自定义函数进行过滤。</p>
<h2 id="RocketMQ生产延迟消息"><a href="#RocketMQ生产延迟消息" class="headerlink" title="RocketMQ生产延迟消息"></a>RocketMQ生产延迟消息</h2><p>RocketMQ是支持延时消息的，只需要在生产消息的时候设置消息的延时级别：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 实例化一个生产者来产生延时消息</span><br><span class="line">DefaultMQProducer producer = new DefaultMQProducer(&quot;ExampleProducerGroup&quot;);</span><br><span class="line">// 启动生产者</span><br><span class="line">producer.start();</span><br><span class="line">int totalMessagesToSend = 100;</span><br><span class="line">for (int i = 0; i &lt; totalMessagesToSend; i++) &#123;</span><br><span class="line">    Message message = new Message(&quot;TestTopic&quot;, (&quot;Hello scheduled message &quot; + i).getBytes());</span><br><span class="line">    // 设置延时等级3,这个消息将在10s之后发送(现在只支持固定的几个时间,详看delayTimeLevel)</span><br><span class="line">    message.setDelayTimeLevel(3);</span><br><span class="line">    // 发送消息</span><br><span class="line">    producer.send(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是目前RocketMQ支持的延时级别是有限的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private String messageDelayLevel = &quot;1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h&quot;;</span><br></pre></td></tr></table></figure>

<h2 id="RocketMQ实现延时消息"><a href="#RocketMQ实现延时消息" class="headerlink" title="RocketMQ实现延时消息"></a>RocketMQ实现延时消息</h2><p>简单，八个字：<code>临时存储</code>+<code>定时任务</code>。</p>
<p>Broker收到延时消息了，会先发送到主题（SCHEDULE_TOPIC_XXXX）的相应时间段的Message Queue中，然后通过一个定时任务轮询这些队列，到期后，把消息投递到目标Topic的队列中，然后消费者就可以正常消费这些消息。</p>
<p><img src="F:\hexo-blog-lionkk-master\hexo-blog-lionkk-master\source_posts\image\648" alt="图片"></p>
<h2 id="RocketMQ通过半消息实现分布式消息事务"><a href="#RocketMQ通过半消息实现分布式消息事务" class="headerlink" title="RocketMQ通过半消息实现分布式消息事务"></a>RocketMQ通过半消息实现分布式消息事务</h2><p>半消息：是指暂时还不能被 Consumer 消费的消息，Producer 成功发送到 Broker 端的消息，但是此消息被标记为 “暂不可投递” 状态，只有等 Producer 端执行完本地事务后经过二次确认了之后，Consumer 才能消费此条消息。</p>
<p>依赖半消息，可以实现分布式消息事务，其中的关键在于二次确认以及消息回查：</p>
<p><img src="F:\hexo-blog-lionkk-master\hexo-blog-lionkk-master\source_posts\image\649" alt="图片"></p>
<p>1、Producer 向 broker 发送半消息</p>
<p>2、Producer 端收到响应，消息发送成功，此时消息是半消息，标记为 “不可投递” 状态，Consumer 消费不了。</p>
<p>3、Producer 端执行本地事务。</p>
<p>4、正常情况本地事务执行完成，Producer 向 Broker 发送 Commit&#x2F;Rollback，如果是 Commit，Broker 端将半消息标记为正常消息，Consumer 可以消费，如果是 Rollback，Broker 丢弃此消息。</p>
<p>5、异常情况，Broker 端迟迟等不到二次确认。在一定时间后，会查询所有的半消息，然后到 Producer 端查询半消息的执行情况。</p>
<p>6、Producer 端查询本地事务的状态</p>
<p>7、根据事务的状态提交 commit&#x2F;rollback 到 broker 端。（5，6，7 是消息回查）</p>
<p>8、消费者段消费到消息之后，执行本地事务，执行本地事务。</p>
<h2 id="RocketMQ解决死信队列"><a href="#RocketMQ解决死信队列" class="headerlink" title="RocketMQ解决死信队列"></a>RocketMQ解决死信队列</h2><p>死信队列用于处理无法被正常消费的消息，即死信消息。</p>
<p>当一条消息初次消费失败，<strong>消息队列 RocketMQ 会自动进行消息重试</strong>；达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息，此时，消息队列 RocketMQ 不会立刻将消息丢弃，而是将其发送到该<strong>消费者对应的特殊队列中</strong>，该特殊队列称为<strong>死信队列</strong>。</p>
<p><strong>死信消息的特点</strong>：</p>
<ul>
<li>不会再被消费者正常消费。</li>
<li>有效期与正常消息相同，均为 3 天，3 天后会被自动删除。因此，需要在死信消息产生后的 3 天内及时处理。</li>
</ul>
<p><strong>死信队列的特点</strong>：</p>
<ul>
<li>一个死信队列对应一个 （消费者组）Group ID， 而不是对应单个消费者实例。</li>
<li>如果一个 Group ID 未产生死信消息，消息队列 RocketMQ 不会为其创建相应的死信队列。</li>
<li>一个死信队列包含了对应 Group ID 产生的所有死信消息，不论该消息属于哪个 Topic。</li>
</ul>
<p>RocketMQ 控制台提供对死信消息的查询、导出和重发的功能。</p>
<h2 id="为什么RocketMQ不使用Zookeeper作为注册中心呢？"><a href="#为什么RocketMQ不使用Zookeeper作为注册中心呢？" class="headerlink" title="为什么RocketMQ不使用Zookeeper作为注册中心呢？"></a>为什么RocketMQ不使用Zookeeper作为注册中心呢？</h2><p>Kafka我们都知道采用Zookeeper作为注册中心——当然也开始逐渐去Zookeeper，RocketMQ不使用Zookeeper其实主要可能从这几方面来考虑：</p>
<ol>
<li>基于可用性的考虑，根据CAP理论，同时最多只能满足两个点，而Zookeeper满足的是CP，也就是说Zookeeper并不能保证服务的可用性，Zookeeper在进行选举的时候，整个选举的时间太长，期间整个集群都处于不可用的状态，而这对于一个注册中心来说肯定是不能接受的，作为服务发现来说就应该是为可用性而设计。</li>
<li>基于性能的考虑，NameServer本身的实现非常轻量，而且可以通过增加机器的方式水平扩展，增加集群的抗压能力，而Zookeeper的写是不可扩展的，Zookeeper要解决这个问题只能通过划分领域，划分多个Zookeeper集群来解决，首先操作起来太复杂，其次这样还是又违反了CAP中的A的设计，导致服务之间是不连通的。</li>
<li>持久化的机制来带的问题，ZooKeeper 的 ZAB 协议对每一个写请求，会在每个 ZooKeeper  节点上保持写一个事务日志，同时再加上定期的将内存数据镜像（Snapshot）到磁盘来保证数据的一致性和持久性，而对于一个简单的服务发现的场景来说，这其实没有太大的必要，这个实现方案太重了。而且本身存储的数据应该是高度定制化的。</li>
<li>消息发送应该弱依赖注册中心，而RocketMQ的设计理念也正是基于此，生产者在第一次发送消息的时候从NameServer获取到Broker地址后缓存到本地，如果NameServer整个集群不可用，短时间内对于生产者和消费者并不会产生太大影响。</li>
</ol>
<h2 id="Broker是怎么保存数据的"><a href="#Broker是怎么保存数据的" class="headerlink" title="Broker是怎么保存数据的"></a>Broker是怎么保存数据的</h2><p>RocketMQ主要的存储文件包括CommitLog文件、ConsumeQueue文件、Indexfile文件。<img src="F:\hexo-blog-lionkk-master\hexo-blog-lionkk-master\source_posts\image\657" alt="图片"></p>
<p>消息存储的整体的设计：</p>
<p><img src="F:\hexo-blog-lionkk-master\hexo-blog-lionkk-master\source_posts\image\656" alt="图片"></p>
<ul>
<li><p><strong>CommitLog</strong>：消息主体以及元数据的存储主体，存储Producer端写入的消息主体内容,消息内容不是定长的。单个文件大小默认1G, 文件名长度为20位，左边补零，剩余为起始偏移量，比如00000000000000000000代表了第一个文件，起始偏移量为0，文件大小为1G&#x3D;1073741824；当第一个文件写满了，第二个文件为00000000001073741824，起始偏移量为1073741824，以此类推。消息主要是顺序写入日志文件，当文件满了，写入下一个文件。</p>
<p>CommitLog文件保存于${Rocket_Home}&#x2F;store&#x2F;commitlog目录中，从图中我们可以明显看出来文件名的偏移量，每个文件默认1G，写满后自动生成一个新的文件。</p>
<p><img src="F:\hexo-blog-lionkk-master\hexo-blog-lionkk-master\source_posts\image\655" alt="图片">CommitLog</p>
</li>
<li><p><strong>ConsumeQueue</strong>：消息消费队列，引入的目的主要是提高消息消费的性能，由于RocketMQ是基于主题topic的订阅模式，消息消费是针对主题进行的，如果要遍历commitlog文件中根据topic检索消息是非常低效的。</p>
<p>Consumer即可根据ConsumeQueue来查找待消费的消息。其中，ConsumeQueue（逻辑消费队列）作为消费消息的索引，保存了指定Topic下的队列消息在CommitLog中的起始物理偏移量offset，消息大小size和消息Tag的HashCode值。</p>
<p>ConsumeQueue文件可以看成是基于Topic的CommitLog索引文件，故ConsumeQueue文件夹的组织方式如下：topic&#x2F;queue&#x2F;file三层组织结构，具体存储路径为：$HOME&#x2F;store&#x2F;consumequeue&#x2F;{topic}&#x2F;{queueId}&#x2F;{fileName}。同样ConsumeQueue文件采取定长设计，每一个条目共20个字节，分别为8字节的CommitLog物理偏移量、4字节的消息长度、8字节tag hashcode，单个文件由30W个条目组成，可以像数组一样随机访问每一个条目，每个ConsumeQueue文件大小约5.72M；</p>
<p><img src="F:\hexo-blog-lionkk-master\hexo-blog-lionkk-master\source_posts\image\654" alt="图片">Comsumer Queue</p>
</li>
<li><p><strong>IndexFile</strong>：IndexFile（索引文件）提供了一种可以通过key或时间区间来查询消息的方法。Index文件的存储位置是：{fileName}，文件名fileName是以创建时的时间戳命名的，固定的单个IndexFile文件大小约为400M，一个IndexFile可以保存 2000W个索引，IndexFile的底层存储设计为在文件系统中实现HashMap结构，故RocketMQ的索引文件其底层实现为hash索引。</p>
<p><img src="F:\hexo-blog-lionkk-master\hexo-blog-lionkk-master\source_posts\image\653" alt="图片">IndexFile文件示意图-来源参考[2]</p>
</li>
</ul>
<p>总结一下：RocketMQ采用的是混合型的存储结构，即为Broker单个实例下所有的队列共用一个日志数据文件（即为CommitLog）来存储。</p>
<p>RocketMQ的混合型存储结构(多个Topic的消息实体内容都存储于一个CommitLog中)针对Producer和Consumer分别采用了数据和索引部分相分离的存储结构，Producer发送消息至Broker端，然后Broker端使用同步或者异步的方式对消息刷盘持久化，保存至CommitLog中。</p>
<p>只要消息被刷盘持久化至磁盘文件CommitLog中，那么Producer发送的消息就不会丢失。正因为如此，Consumer也就肯定有机会去消费这条消息。当无法拉取到消息后，可以等下一次消息拉取，同时服务端也支持长轮询模式，如果一个消息拉取请求未拉取到消息，Broker允许等待30s的时间，只要这段时间内有新消息到达，将直接返回给消费端。</p>
<p>这里，RocketMQ的具体做法是，使用Broker端的后台服务线程—ReputMessageService不停地分发请求并异步构建ConsumeQueue（逻辑消费队列）和IndexFile（索引文件）数据。</p>
<p><img src="F:\hexo-blog-lionkk-master\hexo-blog-lionkk-master\source_posts\image\652" alt="图片"></p>
<h2 id="RocketMQ怎么对文件进行读写的？"><a href="#RocketMQ怎么对文件进行读写的？" class="headerlink" title="RocketMQ怎么对文件进行读写的？"></a>RocketMQ怎么对文件进行读写的？</h2><p>RocketMQ对文件的读写巧妙地利用了操作系统的一些高效文件读写方式——<code>PageCache</code>、<code>顺序读写</code>、<code>零拷贝</code>。</p>
<ul>
<li>PageCache、顺序读取</li>
</ul>
<p>在RocketMQ中，ConsumeQueue逻辑消费队列存储的数据较少，并且是顺序读取，在page cache机制的预读取作用下，Consume Queue文件的读性能几乎接近读内存，即使在有消息堆积情况下也不会影响性能。而对于CommitLog消息存储的日志数据文件来说，读取消息内容时候会产生较多的随机访问读取，严重影响性能。如果选择合适的系统IO调度算法，比如设置调度算法为“Deadline”（此时块存储采用SSD的话），随机读的性能也会有所提升。</p>
<p>页缓存（PageCache)是OS对文件的缓存，用于加速对文件的读写。一般来说，程序对文件进行顺序读写的速度几乎接近于内存的读写速度，主要原因就是由于OS使用PageCache机制对读写访问操作进行了性能优化，将一部分的内存用作PageCache。对于数据的写入，OS会先写入至Cache内，随后通过异步的方式由pdflush内核线程将Cache内的数据刷盘至物理磁盘上。对于数据的读取，如果一次读取文件时出现未命中PageCache的情况，OS从物理磁盘上访问读取文件的同时，会顺序对其他相邻块的数据文件进行预读取。</p>
<ul>
<li>零拷贝</li>
</ul>
<p>另外，RocketMQ主要通过MappedByteBuffer对文件进行读写操作。其中，利用了NIO中的FileChannel模型将磁盘上的物理文件直接映射到用户态的内存地址中（这种Mmap的方式减少了传统IO，将磁盘文件数据在操作系统内核地址空间的缓冲区，和用户应用程序地址空间的缓冲区之间来回进行拷贝的性能开销），将对文件的操作转化为直接对内存地址进行操作，从而极大地提高了文件的读写效率（正因为需要使用内存映射机制，故RocketMQ的文件存储都使用定长结构来存储，方便一次将整个文件映射至内存）。</p>
<h3 id="什么是PageCache"><a href="#什么是PageCache" class="headerlink" title="什么是PageCache"></a>什么是PageCache</h3><h4 id="假如没有PageCache"><a href="#假如没有PageCache" class="headerlink" title="假如没有PageCache:"></a>假如没有PageCache:</h4><p>CPU如果要访问外部磁盘上的文件，由于cpu可以直接访问的存储器是内存。所以磁盘的文件内容要先拷贝到内存上（DMA技术），cup才能读取到。cup访问内存是很快的高速，内存拷贝磁盘文件相对是慢的。（DMA， Direct Memory Access， 存储器直接访问， 允许在外部设备和存储器之间直接读写数据，既不通过CPU，也不需要CPU干预）</p>
<p><img src="F:\hexo-blog-lionkk-master\hexo-blog-lionkk-master\source_posts\image\670" alt="图片"></p>
<p>要优化慢这个问题，就需要提前把磁盘数据先读到内存用做缓存。这个在内存上建立的缓存就是PageCache,也叫页缓存。</p>
<h4 id="PageCache作用"><a href="#PageCache作用" class="headerlink" title="PageCache作用"></a>PageCache作用</h4><p>有了pageCache，cpu要读的数据如果缓存命中，那速度就会快很多。就类似我们好读mysql的数据，如果提前放到redis上面了，速度就会快得多。</p>
<p>pagecache作用就是：缓存 I&#x2F;O ，减少读盘的次数，从而提高性能</p>
<h3 id="PageCache管理"><a href="#PageCache管理" class="headerlink" title="PageCache管理"></a>PageCache管理</h3><p>从前面可以看到，pagecache是放在内存上的，内存同时还有linux内核kernet,app进程这些东西。内存又是有限的，那怎么管理pagecache分配，读取，写入，淘汰就需要有个程序来控制，这个程序就是内核kernet，pagecache的管理是有内核来维护的。</p>
<p>实际上在IO整个过程，其他地方还有缓存的概念</p>
<p><img src="F:\hexo-blog-lionkk-master\hexo-blog-lionkk-master\source_posts\image\671" alt="图片"></p>
<h4 id="（1）app-应用程序-中的缓存区：buffer"><a href="#（1）app-应用程序-中的缓存区：buffer" class="headerlink" title="（1）app(应用程序)中的缓存区：buffer"></a><strong>（1）app(应用程序)中的缓存区：buffer</strong></h4><p>为什么使用buffer会比不使用快？</p>
<p>buffer能一次读取磁盘8k内容先缓存，可以大大减少内核的io次数</p>
<p>Java中BufferedReader，BufferedWriter要比FileReader 和 FileWriter高效</p>
<p>答案就是这里,不用每次读写都调用内核的read&#x2F;write，而是凑齐<code>8190</code>字节后再调用一次系统的read&#x2F;write，本质是较少内核调用磁盘io的次数。</p>
<h4 id="（2）kernel缓存区pagecache"><a href="#（2）kernel缓存区pagecache" class="headerlink" title="（2）kernel缓存区pagecache"></a><strong>（2）kernel缓存区pagecache</strong></h4><p>应用程序在调用系统调用如read(),writer(),就会触发中断信号，此时用户态切换到内核态，内核执行完，数据返回了，cpu又回来继续执行应用程序。</p>
<p>读数据：缓存磁盘热数据，命中直接返回，较少到磁盘次数</p>
<p>写数据：平衡高速设备和低速设备之间的速度</p>
<h4 id="（3）磁盘上面的磁盘缓存区"><a href="#（3）磁盘上面的磁盘缓存区" class="headerlink" title="（3）磁盘上面的磁盘缓存区"></a><strong>（3）磁盘上面的磁盘缓存区</strong></h4><p>磁盘的缓冲区是硬盘与外部总线交换数据的场所。 硬盘的读数据的过程是将磁信号转化为电信号后，通过缓冲区一次次地填充与清空，再填充，再清空，一步步按照PCI总线的周期送出</p>
<h3 id="pageCache读写回收"><a href="#pageCache读写回收" class="headerlink" title="pageCache读写回收"></a>pageCache读写回收</h3><h4 id="（1）读cache"><a href="#（1）读cache" class="headerlink" title="（1）读cache:"></a>（1）读cache:</h4><p>当用户发起一个读请求(假如read()请求)，首先操作系统执行中断，从用户态切换到内核态，内核开始调read()方法。内核会先检查目标数据在pagecache中是否有缓存过，有缓存命中(cache hit)直接返回。没有，缓存穿透，去磁盘中读取，然后把目标数据返回并缓存到pagecache。下次需要同样目标数据就可以在缓存中直接读取。</p>
<h4 id="（2）写cache："><a href="#（2）写cache：" class="headerlink" title="（2）写cache："></a><strong>（2）写cache：</strong></h4><p>用户发起一个写请求(write())，中断（上下文切换）到内核。内核会把要写的数据先写入到pagecache.这时内核并不会马上落盘。而且将page标记为dirty（赃页）,并将其加入dirty_list中。内核会周期性的将dirty_list的数据刷盘(Flusher Threads)。完成了这一步后cache和磁盘中的数据才会最终一致。</p>
<p>刷盘策略(Flusher线程群)：</p>
<p>1.用户进程调用<strong>sync()</strong> 和 **fsync()**系统调用</p>
<p>2.空闲内存低于特定的<strong>阈值</strong>（threshold）</p>
<p>3.Dirty数据在内存中驻留的时间超过一个特定的阈值</p>
<p>相关参数dity：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sysctl -a | grep dirty  </span><br><span class="line">vm.dirty_background_bytes = <span class="number">0</span>       #和 dirty_background_ratio、dirty_ratio 表示同样意义的不同单位的表示</span><br><span class="line">vm.dirty_background_ratio = <span class="number">5</span>       #表示当脏页占总内存的的百分比超过这个值时，后台线程开始刷新脏页。这个值如果设置得太小，可能不能很好地利用内存加速文件操作。如果设置得太大，则会周期性地出现一个写 IO 的峰值。vm.dirty_bytes = <span class="number">0</span>                  #和 dirty_background_ratio、dirty_ratio 表示同样意义的不同单位的表示vm.dirty_expire_centisecs = <span class="number">3000</span>    #示脏数据多久会被刷新到磁盘上。这里的<span class="number">3000</span>表示 <span class="number">30</span>秒vm.dirty_ratio = <span class="number">10</span>                 #当脏页占用的内存百分比超过此值时，内核会阻塞掉写操作，并开始刷新脏页vm.dirty_writeback_centisecs = <span class="number">500</span>  #表示多久唤醒一次刷新脏页的后台线程。这里的<span class="number">500</span>表示５秒唤醒一次。</span><br></pre></td></tr></table></figure>



<p>page cache数量也是有限的，不可能无限增加，那如何释放回收？</p>
<h4 id="（3）cache回收："><a href="#（3）cache回收：" class="headerlink" title="（3）cache回收："></a><strong>（3）cache回收：</strong></h4><p>内核使用的是<strong>LRU算法</strong>和<strong>Two-List策略</strong>(实际上就是怎么回收算法最优的一个机制,其他缓存同样也会面临这个问题，也会有类似的策略)</p>
<p><strong>LRU算法：</strong>least rencently used （最近最少使用），就是要释放最近最少使用的</p>
<p><strong>Two-List策略：</strong>两个list，实际上是维护两个队列(active:活跃的和inactive:不活跃),两个链表。那很明显要干掉不活跃的(加尾砍头)。那这2个表怎么维护？</p>
<p>1.首次缓存的数据page会加入到inactive list中,inactive list中的page被再次访问，则移入active list.</p>
<p>2.如果active list数量远大于inactive list，那么active list头部的page会被移入inactive list,从而实现两个list平衡</p>
<h4 id="（４）缓存淘汰策略：pageCache-VS-redis"><a href="#（４）缓存淘汰策略：pageCache-VS-redis" class="headerlink" title="（４）缓存淘汰策略：pageCache VS redis"></a><strong>（４）缓存淘汰策略：pageCache VS redis</strong></h4><p><img src="F:\hexo-blog-lionkk-master\hexo-blog-lionkk-master\source_posts\image\672" alt="图片"></p>
<h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><p>定义：一种内存映射文件的方法,mmap将一个文件或者其它对象映射进内存。文件被映射到多个页上（PageCache）.</p>
<p><img src="F:\hexo-blog-lionkk-master\hexo-blog-lionkk-master\source_posts\image\673" alt="图片"></p>
<p><strong>作用</strong>：</p>
<p>mmap操作提供了一种机制，让用户程序直接访问设备内存。</p>
<p>什么意思呢，用户空间和内核空间有隔离性，内核才能访问内核空间。用户要直取内核pagecache数据，做不到。需要cup先要从内核的pagecache拷贝一份到用户的缓存区，用户才能访问。有了这个映射之后，用户可以直接操作内核空间的缓存数据。省一步cup拷贝。这种机制，相比较在用户空间和内核空间互相拷贝数据，效率更高。</p>
<h3 id="1、什么是零拷贝？"><a href="#1、什么是零拷贝？" class="headerlink" title="1、什么是零拷贝？"></a>1、什么是零拷贝？</h3><p>零拷贝是指计算机执行IO操作时，CPU不需要将数据从一个存储区域复制到另一个存储区域，进而减少上下文切换以及CPU的拷贝时间。它本质上是一种IO操作优化技术。</p>
<h3 id="2-传统IO的执行流程"><a href="#2-传统IO的执行流程" class="headerlink" title="2.传统IO的执行流程"></a>2.传统IO的执行流程</h3><p>在实际应用中，比如我们需要把磁盘中的某个文件内容发送到远程服务器上，它必须要经过几个拷贝的过程，如下图所示：</p>
<p><img src="F:\hexo-blog-lionkk-master\hexo-blog-lionkk-master\source_posts\image\674" alt="图片"></p>
<p>具体流程如下：</p>
<p>1.应用程序调用read函数，向操作系统发起IO调用。（上下文从用户态切换至内核态）</p>
<p>2.DMA控制器把数据从磁盘中读取到内核缓冲区。</p>
<p>3.CPU把内核缓冲区数据拷贝到用户应用缓冲区（上下文从内核态切换至用户态），此时read函数返回。</p>
<p>4.用户应用进程通过write函数，发起IO调用。（上下文从用户态切换至内核态）</p>
<p>5.CPU将缓冲区的数据拷贝到socket缓冲区。</p>
<p>6.DMA控制器将数据从socket缓冲区拷贝到网卡设备（上下文从内核态切换至用户态），此时write函数返回。</p>
<p>从上面的流程图中可以看出，传统的IO流程包括4次上下文切换，4次拷贝数据（2次CPU拷贝和2次DMA拷贝）。</p>
<h3 id="3-零拷贝实现"><a href="#3-零拷贝实现" class="headerlink" title="3.零拷贝实现"></a>3.零拷贝实现</h3><p>零拷贝并不是没有拷贝数据，而是减少用户态、内核态的切换次数以及CPU拷贝次数；实现零拷贝主要有三种方式分别是</p>
<ul>
<li>mmap + write</li>
<li>sendfle</li>
<li>带有DMA收集拷贝功能的sendfle</li>
</ul>
<h4 id="3-1-mmap"><a href="#3-1-mmap" class="headerlink" title="3.1 mmap"></a>3.1 mmap</h4><p>mmap的函数原型如下：</p>
<p>- </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</span><br><span class="line">addr:指定映射的虚拟内存地址length:映射的长度prot:映射内存的保护模式flags:指定映射的类型fd:进行映射的文件句柄offset:文件偏移量</span><br></pre></td></tr></table></figure>

<p>mmap使用了虚拟内存可以把内核空间和用户空间的虚拟地址映射到同一个物理地址来减少数据拷贝次数的特点，它将内核中的读缓冲区与用户空间的缓冲区进行映射，所有的IO都在内核中完成。</p>
<p>mmap+write实现的零拷贝流程如下图所示：</p>
<p><img src="F:\hexo-blog-lionkk-master\hexo-blog-lionkk-master\source_posts\image\675" alt="图片"></p>
<p>具体流程如下：</p>
<p>1.应用进程通过调用mmap方法向操作系统内核发起IO调用。（上下文从用户态切换至内核态）</p>
<p>2.CPU利用DMA控制器，将数据从硬盘拷贝到内核缓冲区。</p>
<p>3.（上下文从内核态切换回用户态），mmap方法返回。</p>
<p>4.用户进程通过调用write方法向操作系统内核再次发起IO调用。（上下文从用户态切换至内核态）</p>
<p>5.CPU将内核缓冲区的数据拷贝到socket缓冲区。</p>
<p>6.CPU利用DMA控制器，将数据从socket缓冲器拷贝到网卡，（上下文从内核态切换至用户态），write方法返回。</p>
<p>从上图可以发现，mmap+write实现的零拷贝其中发生了4次上线文切换以及3次拷贝(2次DMA拷贝和1次cpu拷贝)</p>
<h4 id="3-2-sendfle"><a href="#3-2-sendfle" class="headerlink" title="3.2 sendfle"></a>3.2 sendfle</h4><p>sendfle是Linux2.1版本后内核引入 的一个系统调用函数，原型如下：</p>
<p>- </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);</span><br></pre></td></tr></table></figure>

<ul>
<li>out_fd:为待写入内容的文件描述符</li>
<li>in_fd:为待读出内容的文件描述符</li>
<li>ofset:文件偏移量</li>
<li>count:指定在fdout和fdin之间传输的字节数</li>
</ul>
<p>sendfle表示在两个文件描述符之间传输数据，它是在操作系统内核中操作的，避免了数据从内核缓冲区和用户缓冲区之间的拷贝操作，因此可以使用它来实现零拷贝。</p>
<p>sendfle实现的零拷贝流程如下图所示：</p>
<p><img src="F:\hexo-blog-lionkk-master\hexo-blog-lionkk-master\source_posts\image\676" alt="图片"></p>
<p>具体流程如下：</p>
<p>1.用户进程发起sendfile系统调用，上下文从用户态切换至内核态</p>
<p>2.DMA控制器将数据从硬盘拷贝到内核缓冲区</p>
<p>3.CPU将读缓冲区中的数据拷贝到socket缓冲区</p>
<p>4.DMA控制器异步把数据从socket缓冲器拷贝到网卡</p>
<p>5.上下文从内核态切换至用户态，sendfle函数返回</p>
<p>从上面可以看出，sendfile实现的零拷贝仅发生了2次上下文切换以及3次拷贝(2次DMA拷贝+1次CPU拷贝)</p>
<h4 id="3-3-sendfle-DMA-scatter-x2F-gather实现的零拷贝"><a href="#3-3-sendfle-DMA-scatter-x2F-gather实现的零拷贝" class="headerlink" title="3.3 sendfle +DMA scatter&#x2F;gather实现的零拷贝"></a>3.3 sendfle +DMA scatter&#x2F;gather实现的零拷贝</h4><p>​    linux2.4版本后，对sendfle做了优化升级，引入SG-DMA技术，其实就是对DMA拷贝加入了scatter&#x2F;gather操作，它可以直接从内核空间缓冲区中将数据读取到网卡，这样的话还可以省去CPU拷贝。如下图所求：</p>
<p><img src="F:\hexo-blog-lionkk-master\hexo-blog-lionkk-master\source_posts\image\677" alt="图片"></p>
<p>具体流程如下：</p>
<p>1.用户进程发起sendfle系统调用，（上下文从用户态切换至内核态）。</p>
<p>2.DMA控制器将数据从磁盘拷贝到内核缓冲器。</p>
<p>3.CPU把内核缓冲区中的文件描述符信息（包括内核缓冲区的内存地址和偏移量）直接发送到socket缓冲区。</p>
<p>4.DMA控制器根据文件描述符信息直接把数据从内核缓冲区拷贝到网卡。</p>
<p>5.（上下文切换至用户态），sendfle返回。</p>
<p>可以发现，sendfle + DMA scatter&#x2F;gather实现的零拷贝发生了2次上下文切换以及2次数据拷贝，这就是真正的零拷贝技术，全程没有通过CPU来搬运数据，所有的数据都是通过DMA进行传输的。</p>
<h3 id="4-java的零拷贝方式"><a href="#4-java的零拷贝方式" class="headerlink" title="4.java的零拷贝方式"></a>4.java的零拷贝方式</h3><h4 id="4-1-mmap"><a href="#4-1-mmap" class="headerlink" title="4.1 mmap"></a>4.1 mmap</h4><p>Java NIO有一个MappedByteBufer的类可以用来实现内存映射。它的底层是调用的linux内核的mmap的API。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shop.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.MappedByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span>: shop-springcloud-alibaba</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@package</span>: com.shop.study</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@className</span>: testStarter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: JaHero</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022/10/30 15:20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testStarter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        SpringApplication.run(testStarter.class, args);</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">readChannel</span> <span class="operator">=</span> FileChannel.open(Paths.get(<span class="string">&quot;D:\\新建文本文档.txt&quot;</span>), StandardOpenOption.READ);</span><br><span class="line">            <span class="type">MappedByteBuffer</span> <span class="variable">data</span> <span class="operator">=</span> readChannel.map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">writeChannel</span> <span class="operator">=</span> FileChannel.open(Paths.get(<span class="string">&quot;D:\\新建文本文档 (3).txt&quot;</span>), StandardOpenOption.WRITE, StandardOpenOption.CREATE);</span><br><span class="line">            <span class="comment">//数据传输</span></span><br><span class="line">            writeChannel.write(data);</span><br><span class="line">            readChannel.close();</span><br><span class="line">            writeChannel.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-2-sendfle"><a href="#4-2-sendfle" class="headerlink" title="4.2 sendfle"></a>4.2 sendfle</h4><p>FileChannel的transferTo()&#x2F;transferFrom()，底层就是sendfle() 系统调用函数。Kafka就是用它实现零拷贝的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">readChannel</span> <span class="operator">=</span> FileChannel.open(Paths.get(<span class="string">&quot;D:\\新建文本文档 (3).txt&quot;</span>), StandardOpenOption.READ);</span><br><span class="line">    <span class="type">long</span> <span class="variable">len</span> <span class="operator">=</span> readChannel.size();</span><br><span class="line">    <span class="type">long</span> <span class="variable">position</span> <span class="operator">=</span> readChannel.position();</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">writeChannel</span> <span class="operator">=</span> FileChannel.open(Paths.get( <span class="string">&quot;D:\\新建文本文档2.txt&quot;</span>), StandardOpenOption.WRITE, StandardOpenOption.CREATE);            <span class="comment">//数据传输</span></span><br><span class="line">    readChannel.transferTo(position, len, writeChannel);</span><br><span class="line">    readChannel.close();</span><br><span class="line">    writeChannel.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="pdflush进程详解"><a href="#pdflush进程详解" class="headerlink" title="pdflush进程详解"></a>pdflush进程详解</h3><p>一、简介<br>   由于页高速缓存的缓存作用，写操作实际上会被延迟。当页高速缓存中的数据比后台存储的数据更新时，那么该数据就被称做脏数据。在内存中累积起来的脏页最终必须被写回磁盘。<br>在以下两种情况发生时，脏页被写回磁盘：<br>1、当空闲内存低于一个特定的阈值时，内核必须将脏页写回磁盘，以便释放内存。<br>2、当脏页在内存中驻留时间超过一个特定的阈值时，内核必须将超时的脏页写回磁盘，以确保脏页不会无限期地驻留在内存中。</p>
<p>上面两种工作的目的完全不同。实际上，在老内核中，这是由两个独立的内核线程分别完成的。但是在2.6内核中，由一群内核线程—pdflush后台回写例程—统一执行两种工作。</p>
<p>我们来看看这两个目标是如何具体实现的。<br>首先，当系统中的空闲内存低于一个特定的阈值时，pdflush线程将脏页刷新回磁盘。该后台回写例程的目的在于在可用物理内存过低时，释放脏页以重新获得内存。特定的内存阈值可以通过dirty_background_ratio参数设置。当空闲内存比阈值dirty_ background_ratio还低时，内核便会调用函数wakeup_bdflush()唤醒一个pdflush线程，随后pdflush线程进一步调用函数background_writeout()开始将脏页写回磁盘。函数background_ writeout()需要一个长整型参数，该参数指定试图回写的页面数目。函数background_writeout()会连续地写出数据，直到满足以下两个条件：<br>1、已经有指定的最小数目的页被写出到磁盘。<br>2、空闲内存数已经回升，超过了阈值dirty_background_ratio。<br>上述条件确保了pdflush操作可以减轻系统中内存不足的压力。回写操作不会在达到这两个条件前停止，除非pdflush写回了所有的脏页，没有剩下的脏页可再被写回了。</p>
<p>要满足第二个目标，pdflush后台例程会被周期性唤醒（和空闲内存是否过低无关），将那些在内存中驻留时间过长的脏页写出，确保内存中不会有长期存在的脏页。加入系统发生崩溃，则内存会处于混乱之中，而那些在内存中还没来得及写回磁盘的脏页就会丢失，所以周期性同步回写非常重要。在系统启动时，内核初始化一个定时器，让它周期地唤醒pdflush线程，随后使其运行函数wb_kupdate()。该函数将把所有驻留时间超过百分之dirty_expire_centisecs秒的脏页写回。然后定时器将再次被初始化为百分之dirty_expire_ centisecs秒后唤醒pdflush线程。总而言之，pdflush线程周期地被唤醒并且把超过特定期限的脏页写回磁盘。 </p>
<h2 id="NIO与IO区别"><a href="#NIO与IO区别" class="headerlink" title="NIO与IO区别"></a>NIO与IO区别</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoxi/p/6576588.html">文章地址</a></p>
<p><strong>一、概念</strong></p>
<p>   NIO即New IO，NIO和IO有相同的作用和目的，但实现方式不同，NIO主要用到的是块，所以NIO的效率要比IO高很多。在Java API中提供了两套NIO，一套是针对标准输入输出NIO，另一套就是网络编程NIO。</p>
<p><strong>二、NIO和IO的主要区别</strong></p>
<p>下表总结了Java IO和NIO之间的主要区别：</p>
<table>
<thead>
<tr>
<th><strong>IO</strong></th>
<th><strong>NIO</strong></th>
</tr>
</thead>
<tbody><tr>
<td>面向流</td>
<td>面向缓冲</td>
</tr>
<tr>
<td>阻塞IO</td>
<td>非阻塞IO</td>
</tr>
<tr>
<td>无</td>
<td>选择器</td>
</tr>
</tbody></table>
<ol>
<li>NIO是以块的方式处理数据，但是IO是以最基础的字节流的形式去写入和读出的。</li>
<li>NIO不在是和IO一样用OutputStream和InputStream 输入流的形式来进行处理数据的，但是又是基于这种流的形式，而是采用了通道和缓冲区的形式来进行处理数据的。</li>
<li>NIO的通道是可以双向的，但是IO中的流只能是单向的。</li>
<li>还有就是NIO的缓冲区（其实也就是一个字节数组）还可以进行分片，可以建立只读缓冲区、直接缓冲区和间接缓冲区，只读缓冲区很明显就是字面意思，直接缓冲区是为加快 I&#x2F;O 速度，而以一种特殊的方式分配其内存的缓冲区。</li>
<li>NIO比传统的BIO核心区别就是，NIO采用的是多路复用的IO模型，普通的IO用的是阻塞的IO模型，两个之间的效率肯定是多路复用效率更高</li>
</ol>
<p><strong>1、面向流与面向缓冲</strong></p>
<p>   Java IO和NIO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要bufferfull方法检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</p>
<p><strong>2、阻塞与非阻塞IO</strong></p>
<p>   Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p>
<p><strong>3、选择器（Selectors）</strong></p>
<p>   Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。</p>
<p><strong>三、NIO和IO如何影响应用程序的设计</strong></p>
<p>无论您选择IO或NIO工具箱，可能会影响您应用程序设计的以下几个方面：</p>
<p>1.对NIO或IO类的API调用。<br>2.数据处理。<br>3.用来处理数据的线程数。</p>
<p><strong>1、API调用</strong></p>
<p>当然，使用NIO的API调用时看起来与使用IO时有所不同，但这并不意外，因为并不是仅从一个InputStream逐字节读取，而是数据必须先读入缓冲区再处理。</p>
<p><strong>2、数据处理</strong></p>
<p>使用纯粹的NIO设计相较IO设计，数据处理也受到影响。</p>
<p>在IO设计中，我们从InputStream或 Reader逐字节读取数据。假设你正在处理一基于行的文本数据流，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Name: Anna </span><br><span class="line">Age: 25</span><br><span class="line">Email: anna@mailserver.com </span><br><span class="line">Phone: 1234567890 </span><br></pre></td></tr></table></figure>

<p>该文本行的流可以这样处理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">InputStream input = ... ; // get the InputStream from the client socket   </span><br><span class="line"></span><br><span class="line">BufferedReader reader = new BufferedReader(new InputStreamReader(input));   </span><br><span class="line"></span><br><span class="line">String nameLine   = reader.readLine(); </span><br><span class="line">String ageLine    = reader.readLine(); </span><br><span class="line">String emailLine  = reader.readLine(); </span><br><span class="line">String phoneLine  = reader.readLine(); </span><br></pre></td></tr></table></figure>

<p>   请注意处理状态由程序执行多久决定。换句话说，一旦reader.readLine()方法返回，你就知道肯定文本行就已读完， readline()阻塞直到整行读完，这就是原因。你也知道此行包含名称；同样，第二个readline()调用返回的时候，你知道这行包含年龄等。 正如你可以看到，该处理程序仅在有新数据读入时运行，并知道每步的数据是什么。一旦正在运行的线程已处理过读入的某些数据，该线程不会再回退数据（大多如此）。下图也说明了这条原则：</p>
<p><img src="F:\hexo-blog-lionkk-master\hexo-blog-lionkk-master\source_posts\image\249993-20170321103837174-107019383.png" alt="img"></p>
<p>而一个NIO的实现会有所不同，下面是一个简单的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate(48); </span><br><span class="line">int bytesRead = inChannel.read(buffer); </span><br></pre></td></tr></table></figure>

<p>注意第二行，从通道读取字节到ByteBuffer。当这个方法调用返回时，你不知道你所需的所有数据是否在缓冲区内。你所知道的是，该缓冲区包含一些字节，这使得处理有点困难。假设第一次 read(buffer)调用后，读入缓冲区的数据只有半行，例如，“Name:An”，你能处理数据吗？显然不能，需要等待，直到整行数据读入缓存，在此之前，对数据的任何处理毫无意义。所以，你怎么知道是否该缓冲区包含足够的数据可以处理呢？好了，你不知道。发现的方法只能查看缓冲区中的数据。其结果是，在你知道所有数据都在缓冲区里之前，你必须检查几次缓冲区的数据。这不仅效率低下，而且可以使程序设计方案杂乱不堪。例如：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate(48);   </span><br><span class="line"></span><br><span class="line">int bytesRead = inChannel.read(buffer);   </span><br><span class="line"></span><br><span class="line">while(! bufferFull(bytesRead) ) &#123;   </span><br><span class="line">       bytesRead = inChannel.read(buffer);   </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>bufferFull()方法必须跟踪有多少数据读入缓冲区，并返回真或假，这取决于缓冲区是否已满。换句话说，如果缓冲区准备好被处理，那么表示缓冲区满了。</p>
<p>bufferFull()方法扫描缓冲区，但必须保持在bufferFull（）方法被调用之前状态相同。如果没有，下一个读入缓冲区的数据可能无法读到正确的位置。这是不可能的，但却是需要注意的又一问题。</p>
<p>如果缓冲区已满，它可以被处理。如果它不满，并且在你的实际案例中有意义，你或许能处理其中的部分数据。但是许多情况下并非如此。下图展示了“缓冲区数据循环就绪”：</p>
<p><img src="F:\hexo-blog-lionkk-master\hexo-blog-lionkk-master\source_posts\image\249993-20170321105822830-639755339.png" alt="img"></p>
<p><strong>四、总结</strong></p>
<p>NIO可让您只使用一个（或几个）单线程管理多个通道（网络连接或文件），但付出的代价是解析数据可能会比从一个阻塞流中读取数据更复杂。</p>
<p>如果需要管理同时打开的成千上万个连接，这些连接每次只是发送少量的数据，例如聊天服务器，实现NIO的服务器可能是一个优势。同样，如果你需要维持许多打开的连接到其他计算机上，如P2P网络中，使用一个单独的线程来管理你所有出站连接，可能是一个优势。一个线程多个连接的设计方案如下图所示：</p>
<p><img src="F:\hexo-blog-lionkk-master\hexo-blog-lionkk-master\source_posts\image\249993-20170321110623815-613575568.png" alt="img"></p>
<p><strong>Java NIO: 单线程管理多个连接</strong></p>
<p>如果你有少量的连接使用非常高的带宽，一次发送大量的数据，也许典型的IO服务器实现可能非常契合。下图说明了一个典型的IO服务器设计：</p>
<p><img src="F:\hexo-blog-lionkk-master\hexo-blog-lionkk-master\source_posts\image\249993-20170321110840033-1588623537.png" alt="img"></p>
<h2 id="RocketMQ实现负载均衡"><a href="#RocketMQ实现负载均衡" class="headerlink" title="RocketMQ实现负载均衡"></a>RocketMQ实现负载均衡</h2><h3 id="Producer的负载均衡"><a href="#Producer的负载均衡" class="headerlink" title="Producer的负载均衡"></a>Producer的负载均衡</h3><p>Producer端在发送消息的时候，会先根据Topic找到指定的TopicPublishInfo，在获取了TopicPublishInfo路由信息后，RocketMQ的客户端在默认方式下selectOneMessageQueue()方法会从TopicPublishInfo中的messageQueueList中选择一个队列（MessageQueue）进行发送消息。具这里有一个sendLatencyFaultEnable开关变量，如果开启，在随机递增取模的基础上，再过滤掉not available的Broker代理。</p>
<p><img src="F:\hexo-blog-lionkk-master\hexo-blog-lionkk-master\source_posts\image\640" alt="图片"></p>
<p>所谓的”latencyFaultTolerance”，是指对之前失败的，按一定的时间做退避。例如，如果上次请求的latency超过550Lms，就退避3000Lms；超过1000L，就退避60000L；如果关闭，采用随机递增取模的方式选择一个队列（MessageQueue）来发送消息，latencyFaultTolerance机制是实现消息发送高可用的核心关键所在。</p>
<h3 id="Consumer的负载均衡"><a href="#Consumer的负载均衡" class="headerlink" title="Consumer的负载均衡"></a>Consumer的负载均衡</h3><p>在RocketMQ中，Consumer端的两种消费模式（Push&#x2F;Pull）都是基于拉模式来获取消息的，而在Push模式只是对pull模式的一种封装，其本质实现为消息拉取线程在从服务器拉取到一批消息后，然后提交到消息消费线程池后，又“马不停蹄”的继续向服务器再次尝试拉取消息。如果未拉取到消息，则延迟一下又继续拉取。在两种基于拉模式的消费方式（Push&#x2F;Pull）中，均需要Consumer端知道从Broker端的哪一个消息队列中去获取消息。因此，有必要在Consumer端来做负载均衡，即Broker端中多个MessageQueue分配给同一个ConsumerGroup中的哪些Consumer消费。</p>
<ol>
<li>Consumer端的心跳包发送</li>
</ol>
<p>在Consumer启动后，它就会通过定时任务不断地向RocketMQ集群中的所有Broker实例发送心跳包（其中包含了，消息消费分组名称、订阅关系集合、消息通信模式和客户端id的值等信息）。Broker端在收到Consumer的心跳消息后，会将它维护在ConsumerManager的本地缓存变量—consumerTable，同时并将封装后的客户端网络通道信息保存在本地缓存变量—channelInfoTable中，为之后做Consumer端的负载均衡提供可以依据的元数据信息。</p>
<ol>
<li><p>Consumer端实现负载均衡的核心类—RebalanceImpl</p>
<p>在Consumer实例的启动流程中的启动MQClientInstance实例部分，会完成负载均衡服务线程—RebalanceService的启动（每隔20s执行一次）。</p>
<p>通过查看源码可以发现，RebalanceService线程的run()方法最终调用的是RebalanceImpl类的rebalanceByTopic()方法，这个方法是实现Consumer端负载均衡的核心。</p>
<p>rebalanceByTopic()方法会根据消费者通信类型为“广播模式”还是“集群模式”做不同的逻辑处理。这里主要来看下集群模式下的主要处理流程：</p>
</li>
</ol>
<p><img src="F:\hexo-blog-lionkk-master\hexo-blog-lionkk-master\source_posts\image\678" alt="图片"></p>
<p>(1) 从rebalanceImpl实例的本地缓存变量—topicSubscribeInfoTable中，获取该Topic主题下的消息消费队列集合（mqSet）；</p>
<p>(2) 根据topic和consumerGroup为参数调用mQClientFactory.findConsumerIdList()方法向Broker端发送通信请求，获取该消费组下消费者Id列表；</p>
<p>(3) 先对Topic下的消息消费队列、消费者Id排序，然后用消息队列分配策略算法（默认为：消息队列的平均分配算法），计算出待拉取的消息队列。这里的平均分配算法，类似于分页的算法，将所有MessageQueue排好序类似于记录，将所有消费端Consumer排好序类似页数，并求出每一页需要包含的平均size和每个页面记录的范围range，最后遍历整个range而计算出当前Consumer端应该分配到的的MessageQueue。</p>
<p><img src="F:\hexo-blog-lionkk-master\hexo-blog-lionkk-master\source_posts\image\679" alt="图片"></p>
<p>(4) 然后，调用updateProcessQueueTableInRebalance()方法，具体的做法是，先将分配到的消息队列集合（mqSet）与processQueueTable做一个过滤比对。<img src="F:\hexo-blog-lionkk-master\hexo-blog-lionkk-master\source_posts\image\680" alt="图片"></p>
<ul>
<li>上图中processQueueTable标注的红色部分，表示与分配到的消息队列集合mqSet互不包含。将这些队列设置Dropped属性为true，然后查看这些队列是否可以移除出processQueueTable缓存变量，这里具体执行removeUnnecessaryMessageQueue()方法，即每隔1s 查看是否可以获取当前消费处理队列的锁，拿到的话返回true。如果等待1s后，仍然拿不到当前消费处理队列的锁则返回false。如果返回true，则从processQueueTable缓存变量中移除对应的Entry；</li>
<li>上图中processQueueTable的绿色部分，表示与分配到的消息队列集合mqSet的交集。判断该ProcessQueue是否已经过期了，在Pull模式的不用管，如果是Push模式的，设置Dropped属性为true，并且调用removeUnnecessaryMessageQueue()方法，像上面一样尝试移除Entry；</li>
<li>最后，为过滤后的消息队列集合（mqSet）中的每个MessageQueue创建一个ProcessQueue对象并存入RebalanceImpl的processQueueTable队列中（其中调用RebalanceImpl实例的computePullFromWhere(MessageQueue mq)方法获取该MessageQueue对象的下一个进度消费值offset，随后填充至接下来要创建的pullRequest对象属性中），并创建拉取请求对象—pullRequest添加到拉取列表—pullRequestList中，最后执行dispatchPullRequest()方法，将Pull消息的请求对象PullRequest依次放入PullMessageService服务线程的阻塞队列pullRequestQueue中，待该服务线程取出后向Broker端发起Pull消息的请求。其中，可以重点对比下，RebalancePushImpl和RebalancePullImpl两个实现类的dispatchPullRequest()方法不同，RebalancePullImpl类里面的该方法为空。</li>
</ul>
<p>消息消费队列在同一消费组不同消费者之间的负载均衡，其核心设计理念是在一个消息消费队列在同一时间只允许被同一消费组内的一个消费者消费，一个消息消费者能同时消费多个消息队列。</p>
<h2 id="RocketMQ消息长轮询"><a href="#RocketMQ消息长轮询" class="headerlink" title="RocketMQ消息长轮询"></a>RocketMQ消息长轮询</h2><p><strong>2.3 Push&#x2F;Pull区别</strong></p>
<p><img src="F:\hexo-blog-lionkk-master\hexo-blog-lionkk-master\source_posts\image\683" alt="图片"></p>
<p><strong>❖ 在实际应用场景中：</strong></p>
<p>➞ 大吞吐量的消息队列都是采用Pull模式，而非Push模式；</p>
<p>➞ 采用Push模式，消费端的性能会影响整个消息队列服务器的性能；</p>
<p>➞采用Push模式，容易造成broker的消息积压，因为broker控制消息的推送速率，消息数量大的话，很难使每个消费者很难适应消息推送速率；</p>
<p>Long-Polling是Pull模式的变种。Pull模型中不管服务端数据有无更新，客户端每隔定长时间拉取一次数据，可能有更新数据返回，也可能什么都没有。Long Polling是指客户端发起Long Polling，此时如果服务端没有消息，会hold住请求，直到服务端有可消费的消息，或者到达超时时间才会返回请求。返回后，客户端又会立即再次发起下一次Long Polling。这种方式解决了Pull模式数据通知不及时的问题，且减少了大量的无效轮询次数。</p>
<p>hold住请求指的服务端暂时不回复结果，保持住相关请求，不关闭请求连接，等相关数据准备好，再写回客户端。</p>
<p>由此可见，<strong>Long-Polling模式下：</strong></p>
<ul>
<li>在Broker一直有可读消息的情况下，Long-Polling就等价于执行间隔为0的Pull模式（每次收到Pull结果就发起下一次Pull请求，当然也可根据实际情况设置最小间隔保护时间或单批次最小消息数量）；</li>
<li>在Broker没有可读消息的情况下，请求阻塞在了Broker，在产生下一条消息或者请求“超时之前”响应请求给Consumer。</li>
</ul>
<p><img src="F:\hexo-blog-lionkk-master\hexo-blog-lionkk-master\source_posts\image\681" alt="图片"></p>
<ul>
<li><p>PullMessageProcessor#processRequest</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//如果没有拉到数据</span><br><span class="line">case ResponseCode.PULL_NOT_FOUND:</span><br><span class="line">    // broker 和 consumer 都允许 suspend，默认开启</span><br><span class="line">    if (brokerAllowSuspend &amp;&amp; hasSuspendFlag) &#123;</span><br><span class="line">        long pollingTimeMills = suspendTimeoutMillisLong;</span><br><span class="line">        if (!this.brokerController.getBrokerConfig().isLongPollingEnable()) &#123;</span><br><span class="line">            pollingTimeMills = this.brokerController.getBrokerConfig().getShortPollingTimeMills();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        String topic = requestHeader.getTopic();</span><br><span class="line">        long offset = requestHeader.getQueueOffset();</span><br><span class="line">        int queueId = requestHeader.getQueueId();</span><br><span class="line">        //封装一个PullRequest</span><br><span class="line">        PullRequest pullRequest = new PullRequest(request, channel, pollingTimeMills,</span><br><span class="line">                this.brokerController.getMessageStore().now(), offset, subscriptionData, messageFilter);</span><br><span class="line">        //把PullRequest挂起来</span><br><span class="line">        this.brokerController.getPullRequestHoldService().suspendPullRequest(topic, queueId, pullRequest);</span><br><span class="line">        response = null;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>创建pullRequest并挂起，通过</p>
<p>挂起的请求，有一个服务线程会不停地检查，看queue中是否有数据，或者超时。</p>
<ul>
<li>PullRequestHoldService#run()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125; service started&quot;</span>, <span class="built_in">this</span>.getServiceName());</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.brokerController.getBrokerConfig().isLongPollingEnable()) &#123;</span><br><span class="line">                <span class="built_in">this</span>.waitForRunning(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.waitForRunning(<span class="built_in">this</span>.brokerController.getBrokerConfig().getShortPollingTimeMills());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">long</span> <span class="variable">beginLockTimestamp</span> <span class="operator">=</span> <span class="built_in">this</span>.systemClock.now();</span><br><span class="line">            <span class="comment">//检查hold住的请求</span></span><br><span class="line">            <span class="built_in">this</span>.checkHoldRequest();</span><br><span class="line">            <span class="type">long</span> <span class="variable">costTime</span> <span class="operator">=</span> <span class="built_in">this</span>.systemClock.now() - beginLockTimestamp;</span><br><span class="line">            <span class="keyword">if</span> (costTime &gt; <span class="number">5</span> * <span class="number">1000</span>) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;[NOTIFYME] check hold request cost &#123;&#125; ms.&quot;</span>, costTime);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            log.warn(<span class="built_in">this</span>.getServiceName() + <span class="string">&quot; service has exception. &quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125; service end&quot;</span>, <span class="built_in">this</span>.getServiceName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="RocketMQ消息过滤机制详解"><a href="#RocketMQ消息过滤机制详解" class="headerlink" title="RocketMQ消息过滤机制详解"></a>RocketMQ消息过滤机制详解</h1><p>RocketMQ支持表达式过滤与类过滤两种模式，其中表达式又分为TAG和SQL92。类过滤模式允许提交一个过滤类到FilterServer，消息消费者从FilterServer拉取消息，消息经过FilterServer时会执行过滤逻辑。</p>
<h2 id="基于表达式的消息过滤"><a href="#基于表达式的消息过滤" class="headerlink" title="基于表达式的消息过滤"></a>基于表达式的消息过滤</h2><p>　　消息发送者在消息发送时如果设置了消息的tags属性，存储在消息属性中，先存储在CommitLog文件中，然后转发到消息消费队列，消息消费队列会用8个字节存储消息tag的hashcode，之所以不直接存储tag字符串，是因为将ConumeQueue设计为定长结构，加快消息消费的加载性能。<br>　　<strong>RocketMQ基于表达式的消息过滤是在订阅时做过滤。在Broker端拉取消息时，遍历ConsumeQueue，只对比消息tag的hashcode</strong>，如果匹配则返回，否则忽略该消息。<strong>Consume在收到消息后，同样需要先对消息进行过滤，只是此时比较的是消息tag的值而不再是hashcode</strong>。</p>
<p>Step1：<strong>消费者订阅消息主题与消息过滤表达式。</strong>构建订阅信息subscriptionData并加入到RebalanceImpl进行消息队列负载。<br>　　subscriptionData的核心属性：<br>　　1）String SUB_ALL：过滤模式，默认为全匹配。<br>　　2）boolean classFilterMode：是否是类过滤模式，默认为false。<br>　　3）String topic：消息主题名称。<br>　　4）<strong>String subString：消息过滤表达式，多个用双竖线隔开，例如“TAGA||TAGB”。</strong><br>　　5）<strong>Set<String> tagsSet：消息过滤tag集合，消费端过滤时进行消息过滤的依据。</strong><br>　　6）Set<String> codeSet：消息过滤tag hashcode集合。<br>　　7）String expressionType：过滤类型，TAG或SQL92。<br>Step2：根据订阅消息构建消息拉取标记。根据主题、消息过滤表达式构建订阅消息实体。构建消息过滤对象。<br>Step3：根据偏移量拉取消息后，首先根据ConsumeQueue条目进行消息过滤，如果不匹配则直接跳过该条消息，继续拉取下一条消息。<br>Step4：如果消息根据ConsumeQueue条目通过过滤，则需要从CommitLog文件中加载整个消息体，然后根据属性进行过滤。基于TAG模式，根据ConsumeQueue进行消息过滤时只对比tag的hashcode，所以基于TAG模式消息过滤，还需要在消息消费端对消息tag进行精确匹配。</p>
<p>　　从消息拉取流程知道，消息拉取线程PullMessageService默认会使用异步方式从服务器拉取消息，如果消息过滤模式为TAG模式，并且订阅TAG集合不为空，则对消息的tag进行判断，如果集合中包含消息的TAG则返回给消费者消费，否则跳过。</p>
<h2 id="消息过滤FilterServer"><a href="#消息过滤FilterServer" class="headerlink" title="消息过滤FilterServer"></a>消息过滤FilterServer</h2><h3 id="ClassFilter运行机制"><a href="#ClassFilter运行机制" class="headerlink" title="ClassFilter运行机制"></a>ClassFilter运行机制</h3><p>　　基于类模式过滤是指在 Broker 端运行1个或多个消息过滤服务器（FilterServer）, RocketMQ 允许消息消费者自定义消息过滤实现类并将其代码上传到 FilterServer 上，消息消费者向 FilterServer 拉取消息，FilterServer将消息消费者的拉取命令转发到 Broker，然后对返回的消息执行消息过滤逻辑，最终将消息返回给消费端。</p>
<p><img src="F:\hexo-blog-lionkk-master\hexo-blog-lionkk-master\source_posts\image\682.png" alt="img"></p>
<p><strong>1）Broker 进程所在的服务器会启动多个 FilterServer 进程。</strong><br><strong>2）消费者在订阅消息主题时会上传一个自定义的消息过滤实现类，FilterServer 加载并实例化。</strong><br><strong>3）消息消费者（Consume）向 FilterServer 发送消息拉取请求，FilterServer 接收到消息消费者消息拉取请求后，FilterServer 将消息拉取请求转发给 Broker，Broker 返回消息后在 FilterServer 端执行消息过滤逻辑，然后返回符合订阅信息的消息给消息消费者进行消费。</strong></p>
<h3 id="FilterServer-注册"><a href="#FilterServer-注册" class="headerlink" title="FilterServer 注册"></a>FilterServer 注册</h3><p>　　FilterServer在启动时会创建一个定时调度任务，每隔10s向Broker注册自己。<br>　　Step1：FilterServer从配置文件中获取Broker地址，然后将FilterServer所在机器的IP与监听端口发送到Broker服务器。<br>　　Step2：FilterServer与Broker通过心跳维持FilterServer在Broker端的注册，同样在Broker每隔10s扫描一下该注册表，如果30s内未收到FilterServer的注册信息，将关闭Broker与FilterServer的连接。Broker为了避免Broker端FilterServer的异常退出导致FilterServer进程越来越少，同样提供一个定时任务每30s检测一下当前存活的FilterServer进程个数。<br>　　经过上面的步骤，Broker上已经保存了FilterServer的信息。那么NameServer中关于Broker的filterServer信息是如何从消息服务器（Broker）传输到NameServer的呢？Broker通过与所有NameServer的心跳包向NameServer注册Broker上存储的FilterServer列表，指引消息消费者正确从FilterServer上拉取消息。Brokers每30s向所有NameServer发送心跳包，心跳包中包含了集群名称、Broker名称、Broker地址、BrokerId、haServer地址、topic配置、过滤服务器列表等。</p>
<h3 id="类过滤模式订阅机制"><a href="#类过滤模式订阅机制" class="headerlink" title="类过滤模式订阅机制"></a>类过滤模式订阅机制</h3><p>　　RocketMQ 通过DefaultMQPushConsumerimpl#subscribe方法来实现基于类模式的消息过滤，其参数分别代表消费组订阅的消息主题、类过滤全路径名、类过滤源代码字符串 。<br>　　Step1：构建订阅信息，然后将该订阅信息添加到 Rebalancelmpl 中，其主要目标是Rebalancelmpl会对订阅信息表中的主题进行消息队列的负载，创建消息拉取任务，以便PullMessageService 线程拉取消息 。<br>　　Step2：定时将消息端订阅信息中的类过滤模式的过滤类源码上传到 FilterServer。<br>　　Step3：根据订阅的主题获取该主题的路由信息，如果该主题路由信息中的FilterServer缓存表不为空，则需要<strong>将过滤类发送到FilterServer上</strong>。<br>　　Step4：遍历主题路由表中的 fiIterServerTable，向缓存中所有的 FilterServer 上传消息过滤代码 。<br>　　Step5：<strong>FilterServer 端处理 FilterClass上传并将其源码编译的实现为FilterClassManager 。</strong><br>　　Step6：根据消息消费组与主题名称构建 filterClasTable 缓存 key，从缓存表中尝试获取过滤类型信息FilterClasslnfo。如果缓存表中不包含 FilterClasslnfo 则表示第一次注册，设置 registerNew 为true；如果 FilterClasslnfo不为空，说明该消息消费组不是第一次注册。如果服务端开启允许消息消费者上传FilterClass，比较两个的 classCRC，如果不相同，说明FilterClass 的源码发生了变化，设置 registerNew 为 true 。<br>　　Step7：<strong>如果是第一次注册，则创建 FilterClasslnfo，如果 FilterServer 允许消息消费者上传过滤类源码，则使用 JDK 提供的方法将源代码编译并加装，然后创建其实例，并强制类型转换为 MessageFilter</strong>，也就是自定义的消息过滤类必须实现 MessageFilter 接口 。<br>　　上述整个过程就完成了消息消费端向 FilterServer 上传过滤类的过程，但如果FilterServer 不允许消息消费者上传 FilterC!ass ，则 filterServerTable 中存在的过滤类信息只包含className、classCRC、消息过滤类 MessageFilter 属性都为空，也就是说会忽略消息消费者上传的过滤类源代码，那过滤类的源码从哪获取呢？FilterServer 会开启一个定时任务，每隔1分钟从远程服务器下载过滤类源码，再将其编译与实例化。</p>
<h3 id="消息拉取"><a href="#消息拉取" class="headerlink" title="消息拉取"></a>消息拉取</h3><p>　　RocketMQ 消息的过滤发生在消息消费的时候，PullMessageService 线程默认从Broker上拉取消息，执行相关的过滤逻辑。<br>　　Step1：在FilterServer过滤模式下，在消息拉取时，如果发现消息过滤模式为classFilter，将拉取消息服务器地址由原来的Broker地址转换成该Broker服务器所对应的FilterServer。<br>　　Step2：获取该消息主题的路由信息，从路由信息中获取 Broker 对应的FilterServer列表，如果不为空则随机从FilterServer列表中选择一个FilterServer，发送拉取消息请求至相应的FilterServer上，<strong>FilterServer将拉取请求转发给Broker，然后对返回的消息执行消息过滤逻辑，在过滤服务器将消息过滤后再返回给消息消费者</strong>。</p>
<h3 id="类过滤模式相比TAG模式过滤的优势"><a href="#类过滤模式相比TAG模式过滤的优势" class="headerlink" title="类过滤模式相比TAG模式过滤的优势"></a>类过滤模式相比TAG模式过滤的优势</h3><p>1 ）基于TAG模式消息过滤，由于在消息服务端进行消息过滤是匹配消息TAG的hashcode，导致服务端过滤并不十分准确，从服务端返回的消息最终并不一定是消息消费者订阅的消息，造成网络带宽的浪费，而基于类模式的消息过滤所有的过滤操作全部在FilterServer端进行。<br>2 ）由于FilterServer 与 Broker 运行在同一台 机器上，消息的传输是通过本地回环通信，不会浪费Broker端的网络资源 。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">JaHero</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/12/26/RocketMQ/RocketMQ/">http://example.com/2022/12/26/RocketMQ/RocketMQ/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">贾英雄-blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/RocketMQ/">RocketMQ</a></div><div class="post_share"><div class="social-share" data-image="/img/post.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://fastly.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/12/26/RocketMQ/RocketMQ%20dashboard%20%E5%AE%89%E8%A3%85/" title="缓存的穿透、雪崩、击穿"><img class="cover" src="/img/post.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-26</div><div class="title">缓存的穿透、雪崩、击穿</div></div></a></div><div><a href="/pages/9708e2/" title="《RocketMQ 技术内幕》笔记"><img class="cover" src="/img/post.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-12</div><div class="title">《RocketMQ 技术内幕》笔记</div></div></a></div><div><a href="/pages/d404be/" title="RocketMQ 快速入门"><img class="cover" src="/img/post.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-17</div><div class="title">RocketMQ 快速入门</div></div></a></div><div><a href="/pages/36eab6/" title="RocketMQ 基本原理"><img class="cover" src="/img/post.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-08</div><div class="title">RocketMQ 基本原理</div></div></a></div><div><a href="/pages/518800/" title="RocketMQ FAQ"><img class="cover" src="/img/post.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-12</div><div class="title">RocketMQ FAQ</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/ava.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">JaHero</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">495</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">294</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">118</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/JiaHero7/JiaHero7.github.io/" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#RocketMQ"><span class="toc-number">1.</span> <span class="toc-text">RocketMQ</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RocketMQ%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.1.</span> <span class="toc-text">RocketMQ优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">消息队列模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RocketMQ%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">RocketMQ模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.</span> <span class="toc-text">消费模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RocketMQ%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84"><span class="toc-number">1.5.</span> <span class="toc-text">RocketMQ基本架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RocketMQ%E6%A1%86%E6%9E%B6%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">1.6.</span> <span class="toc-text">RocketMQ框架核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NameServer"><span class="toc-number">1.6.1.</span> <span class="toc-text">NameServer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Broker"><span class="toc-number">1.6.2.</span> <span class="toc-text">Broker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Producer"><span class="toc-number">1.6.3.</span> <span class="toc-text">Producer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Consumer"><span class="toc-number">1.6.4.</span> <span class="toc-text">Consumer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RocketMQ%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="toc-number">1.7.</span> <span class="toc-text">RocketMQ保证消息的高可用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E9%98%B6%E6%AE%B5"><span class="toc-number">1.7.1.</span> <span class="toc-text">生产阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E9%98%B6%E6%AE%B5"><span class="toc-number">1.7.2.</span> <span class="toc-text">存储阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E9%98%B6%E6%AE%B5"><span class="toc-number">1.7.3.</span> <span class="toc-text">消费阶段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RocketMQ%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="toc-number">1.8.</span> <span class="toc-text">RocketMQ的高可用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RocketMQ%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF%E4%B8%8D%E9%87%8D%E5%A4%8D"><span class="toc-number">1.9.</span> <span class="toc-text">RocketMQ处理消息不重复</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.9.1.</span> <span class="toc-text">产生原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E5%B9%82%E7%AD%89"><span class="toc-number">1.9.2.</span> <span class="toc-text">业务幂等</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%8E%BB%E9%87%8D"><span class="toc-number">1.9.3.</span> <span class="toc-text">消息去重</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RocketMQ%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF%E7%A7%AF%E5%8E%8B"><span class="toc-number">1.10.</span> <span class="toc-text">RocketMQ处理消息积压</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E6%89%A9%E5%AE%B9%EF%BC%88%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%8D%E8%B6%B3%EF%BC%89"><span class="toc-number">1.10.1.</span> <span class="toc-text">消费者扩容（消费者不足）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E8%BF%81%E7%A7%BBQueue%E6%89%A9%E5%AE%B9"><span class="toc-number">1.10.2.</span> <span class="toc-text">消息迁移Queue扩容</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RocketMQ%E5%AE%9E%E7%8E%B0%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF"><span class="toc-number">1.11.</span> <span class="toc-text">RocketMQ实现顺序消息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%83%A8%E5%88%86%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF"><span class="toc-number">1.11.0.1.</span> <span class="toc-text">部分顺序消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF"><span class="toc-number">1.11.0.2.</span> <span class="toc-text">全局顺序消息</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RocketMQ%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E8%BF%87%E6%BB%A4"><span class="toc-number">1.12.</span> <span class="toc-text">RocketMQ实现消息过滤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RocketMQ%E7%94%9F%E4%BA%A7%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF"><span class="toc-number">1.13.</span> <span class="toc-text">RocketMQ生产延迟消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RocketMQ%E5%AE%9E%E7%8E%B0%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF"><span class="toc-number">1.14.</span> <span class="toc-text">RocketMQ实现延时消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RocketMQ%E9%80%9A%E8%BF%87%E5%8D%8A%E6%B6%88%E6%81%AF%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.15.</span> <span class="toc-text">RocketMQ通过半消息实现分布式消息事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RocketMQ%E8%A7%A3%E5%86%B3%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97"><span class="toc-number">1.16.</span> <span class="toc-text">RocketMQ解决死信队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88RocketMQ%E4%B8%8D%E4%BD%BF%E7%94%A8Zookeeper%E4%BD%9C%E4%B8%BA%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%91%A2%EF%BC%9F"><span class="toc-number">1.17.</span> <span class="toc-text">为什么RocketMQ不使用Zookeeper作为注册中心呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Broker%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E5%AD%98%E6%95%B0%E6%8D%AE%E7%9A%84"><span class="toc-number">1.18.</span> <span class="toc-text">Broker是怎么保存数据的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RocketMQ%E6%80%8E%E4%B9%88%E5%AF%B9%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E8%AF%BB%E5%86%99%E7%9A%84%EF%BC%9F"><span class="toc-number">1.19.</span> <span class="toc-text">RocketMQ怎么对文件进行读写的？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFPageCache"><span class="toc-number">1.19.1.</span> <span class="toc-text">什么是PageCache</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%87%E5%A6%82%E6%B2%A1%E6%9C%89PageCache"><span class="toc-number">1.19.1.1.</span> <span class="toc-text">假如没有PageCache:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PageCache%E4%BD%9C%E7%94%A8"><span class="toc-number">1.19.1.2.</span> <span class="toc-text">PageCache作用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PageCache%E7%AE%A1%E7%90%86"><span class="toc-number">1.19.2.</span> <span class="toc-text">PageCache管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89app-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-%E4%B8%AD%E7%9A%84%E7%BC%93%E5%AD%98%E5%8C%BA%EF%BC%9Abuffer"><span class="toc-number">1.19.2.1.</span> <span class="toc-text">（1）app(应用程序)中的缓存区：buffer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89kernel%E7%BC%93%E5%AD%98%E5%8C%BApagecache"><span class="toc-number">1.19.2.2.</span> <span class="toc-text">（2）kernel缓存区pagecache</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E7%A3%81%E7%9B%98%E4%B8%8A%E9%9D%A2%E7%9A%84%E7%A3%81%E7%9B%98%E7%BC%93%E5%AD%98%E5%8C%BA"><span class="toc-number">1.19.2.3.</span> <span class="toc-text">（3）磁盘上面的磁盘缓存区</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pageCache%E8%AF%BB%E5%86%99%E5%9B%9E%E6%94%B6"><span class="toc-number">1.19.3.</span> <span class="toc-text">pageCache读写回收</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E8%AF%BBcache"><span class="toc-number">1.19.3.1.</span> <span class="toc-text">（1）读cache:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%86%99cache%EF%BC%9A"><span class="toc-number">1.19.3.2.</span> <span class="toc-text">（2）写cache：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89cache%E5%9B%9E%E6%94%B6%EF%BC%9A"><span class="toc-number">1.19.3.3.</span> <span class="toc-text">（3）cache回收：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%EF%BC%94%EF%BC%89%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%EF%BC%9ApageCache-VS-redis"><span class="toc-number">1.19.3.4.</span> <span class="toc-text">（４）缓存淘汰策略：pageCache VS redis</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mmap"><span class="toc-number">1.19.4.</span> <span class="toc-text">mmap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%B6%E6%8B%B7%E8%B4%9D%EF%BC%9F"><span class="toc-number">1.19.5.</span> <span class="toc-text">1、什么是零拷贝？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BC%A0%E7%BB%9FIO%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.19.6.</span> <span class="toc-text">2.传统IO的执行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%9B%B6%E6%8B%B7%E8%B4%9D%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.19.7.</span> <span class="toc-text">3.零拷贝实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-mmap"><span class="toc-number">1.19.7.1.</span> <span class="toc-text">3.1 mmap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-sendfle"><span class="toc-number">1.19.7.2.</span> <span class="toc-text">3.2 sendfle</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-sendfle-DMA-scatter-x2F-gather%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.19.7.3.</span> <span class="toc-text">3.3 sendfle +DMA scatter&#x2F;gather实现的零拷贝</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-java%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%96%B9%E5%BC%8F"><span class="toc-number">1.19.8.</span> <span class="toc-text">4.java的零拷贝方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-mmap"><span class="toc-number">1.19.8.1.</span> <span class="toc-text">4.1 mmap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-sendfle"><span class="toc-number">1.19.8.2.</span> <span class="toc-text">4.2 sendfle</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pdflush%E8%BF%9B%E7%A8%8B%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.19.9.</span> <span class="toc-text">pdflush进程详解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO%E4%B8%8EIO%E5%8C%BA%E5%88%AB"><span class="toc-number">1.20.</span> <span class="toc-text">NIO与IO区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RocketMQ%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">1.21.</span> <span class="toc-text">RocketMQ实现负载均衡</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Producer%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">1.21.1.</span> <span class="toc-text">Producer的负载均衡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Consumer%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">1.21.2.</span> <span class="toc-text">Consumer的负载均衡</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RocketMQ%E6%B6%88%E6%81%AF%E9%95%BF%E8%BD%AE%E8%AF%A2"><span class="toc-number">1.22.</span> <span class="toc-text">RocketMQ消息长轮询</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RocketMQ%E6%B6%88%E6%81%AF%E8%BF%87%E6%BB%A4%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3"><span class="toc-number">2.</span> <span class="toc-text">RocketMQ消息过滤机制详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%B6%88%E6%81%AF%E8%BF%87%E6%BB%A4"><span class="toc-number">2.1.</span> <span class="toc-text">基于表达式的消息过滤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E8%BF%87%E6%BB%A4FilterServer"><span class="toc-number">2.2.</span> <span class="toc-text">消息过滤FilterServer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ClassFilter%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">2.2.1.</span> <span class="toc-text">ClassFilter运行机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FilterServer-%E6%B3%A8%E5%86%8C"><span class="toc-number">2.2.2.</span> <span class="toc-text">FilterServer 注册</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%BC%8F%E8%AE%A2%E9%98%85%E6%9C%BA%E5%88%B6"><span class="toc-number">2.2.3.</span> <span class="toc-text">类过滤模式订阅机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%8B%89%E5%8F%96"><span class="toc-number">2.2.4.</span> <span class="toc-text">消息拉取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%BC%8F%E7%9B%B8%E6%AF%94TAG%E6%A8%A1%E5%BC%8F%E8%BF%87%E6%BB%A4%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">2.2.5.</span> <span class="toc-text">类过滤模式相比TAG模式过滤的优势</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/12/31/image/%E7%AC%AC%E4%B8%80%E5%A4%A9%E7%AC%94%E8%AE%B0/" title="无题"><img src="/img/post.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2022/12/31/image/%E7%AC%AC%E4%B8%80%E5%A4%A9%E7%AC%94%E8%AE%B0/" title="无题">无题</a><time datetime="2022-12-31T04:24:34.153Z" title="发表于 2022-12-31 12:24:34">2022-12-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/31/img/index/" title="gallery"><img src="/img/post.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="gallery"/></a><div class="content"><a class="title" href="/2022/12/31/img/index/" title="gallery">gallery</a><time datetime="2022-12-30T18:20:45.000Z" title="发表于 2022-12-31 02:20:45">2022-12-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/30/hello-world/" title="Hello World"><img src="/img/post.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/2022/12/30/hello-world/" title="Hello World">Hello World</a><time datetime="2022-12-30T09:13:14.141Z" title="发表于 2022-12-30 17:13:14">2022-12-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/26/Aop%E6%B3%A8%E8%A7%A3/" title="Aop注解"><img src="/img/post.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Aop注解"/></a><div class="content"><a class="title" href="/2022/12/26/Aop%E6%B3%A8%E8%A7%A3/" title="Aop注解">Aop注解</a><time datetime="2022-12-26T04:40:09.000Z" title="发表于 2022-12-26 12:40:09">2022-12-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/26/Flowable%20%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%BC%95%E6%93%8E/" title="Flowable 工作流程引擎"><img src="/img/post.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Flowable 工作流程引擎"/></a><div class="content"><a class="title" href="/2022/12/26/Flowable%20%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%BC%95%E6%93%8E/" title="Flowable 工作流程引擎">Flowable 工作流程引擎</a><time datetime="2022-12-26T04:40:09.000Z" title="发表于 2022-12-26 12:40:09">2022-12-26</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/post.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 By JaHero</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/algolia.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script src="https://fastly.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>